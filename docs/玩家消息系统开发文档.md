# 玩家消息系统开发文档

## 1. 文档目的

本文档用于指导实现一个通用的玩家消息系统（MessageSys），参考 `server/server/gameserver/logicworker/actorsystem/messagesys.go` 的实现。

**核心功能**：
- 当玩家下线时，收到消息不能立即处理，存入数据库
- 当玩家上线时，从数据库加载消息并处理
- 支持任意类型的消息（通过 msgType 和 msg 字节数组）
- 提供消息注册机制，允许其他系统注册消息处理回调

## 2. 参考实现分析

### 2.1  项目 messagesys.go 核心逻辑

**主要功能**：
1. **消息存储**：玩家下线时，消息通过 `GMsgAddActorMsg` 存入数据库
2. **消息加载**：玩家上线时，通过 `loadMsgFromDB` 从数据库加载消息
3. **消息处理**：通过 `OnRecvMessage` 处理消息，调用注册的回调函数
4. **消息删除**：处理完成后通过 `deleteDBMsg` 删除数据库中的消息

**关键方法**：
- `OnInit()`：系统初始化时加载消息
- `OnReconnect()`：重连时加载消息
- `loadMsgFromDB(msgId int64)`：从数据库加载消息（支持增量加载）
- `onLoadMsgFromDB(msgs []*gshare.MsgSt)`：处理加载的消息
- `OnRecvMessage(msgType int, msg pb3.Message)`：处理消息，调用注册的回调
- `deleteDBMsg(msgId int64)`：删除已处理的消息

**消息结构**：
```go
type MsgSt struct {
    MsgId   int64
    MsgType int
    Msg     []byte
}
```

**消息注册机制**：
- 通过 `engine.GetMessageCallback(msgType)` 获取消息处理回调
- 通过 `engine.GetMessagePb3(msgType)` 获取消息的 Protobuf 结构

### 2.2 当前项目架构

**EntitySystem 系统**：
- 系统通过 `RegisterSystemFactory` 注册
- 系统ID在 `protocol.SystemId` 中定义
- PlayerRole 通过 sysMgr 管理系统
- 系统基类为 `BaseSystem`

**已有离线消息系统**：
- 仅用于聊天系统（ChatMessage）
- 数据库表：`OfflineMessage`
- 存储结构：针对聊天消息设计，包含 `ChatType`、`SenderId`、`Content` 等字段

## 3. 设计方案

### 3.1 数据库设计

**新增表：`PlayerActorMessage`**

```go
// PlayerActorMessage 玩家Actor消息表
type PlayerActorMessage struct {
    ID        uint   `gorm:"primaryKey;autoIncrement"`
    RoleId    uint64 `gorm:"not null;index"`        // 目标角色ID
    MsgType   int32  `gorm:"not null;index"`       // 消息类型（对应 protocol 中的消息ID）
    MsgData   []byte `gorm:"type:blob;not null"`   // 消息数据（Protobuf序列化后的字节数组）
    CreatedAt int64  `gorm:"not null;index"`       // 创建时间（Unix时间戳，秒）
}
```

**数据库操作函数**（在 `server/internal/database/player_actor_message.go` 中实现）：
- `SavePlayerActorMessage(roleId uint64, msgType int32, msgData []byte) error`：保存消息
- `LoadPlayerActorMessages(roleId uint64, afterMsgId uint64) ([]*PlayerActorMessage, error)`：加载消息（支持增量加载）
- `DeletePlayerActorMessage(msgId uint64) error`：删除单条消息
- `DeletePlayerActorMessages(roleId uint64) error`：删除玩家的所有消息
- `GetPlayerActorMessageCount(roleId uint64) (int64, error)`：获取消息数量

### 3.2 系统设计

**系统ID**：
- 在 `proto/csproto/system.proto` 中新增 `SystemId_SysMessage = XX`
- 在 `server/internal/protocol/system.pb.go` 中会自动生成

**MessageSys 系统结构**：

```go
type MessageSys struct {
    entitysystem.BaseSystem
    owner iface.IPlayerRole
}
```

**核心方法**：
1. `OnInit(ctx context.Context)`：系统初始化时加载消息
2. `OnRoleLogin(ctx context.Context)`：玩家登录时加载消息
3. `OnRoleReconnect(ctx context.Context)`：玩家重连时加载消息
4. `loadMsgFromDB(afterMsgId uint64)`：从数据库加载消息（支持增量加载）
5. `onLoadMsgFromDB(msgs []*PlayerActorMessage)`：处理加载的消息
6. `OnRecvMessage(msgType int32, msgData []byte)`：处理消息，调用注册的回调
7. `deleteDBMsg(msgId uint64)`：删除已处理的消息

### 3.3 消息注册机制

**消息回调注册**（在 `server/service/gameserver/internel/engine` 中实现）：

```go
// 消息回调函数类型
type MessageCallbackFunc func(owner iface.IPlayerRole, msg proto.Message) error

// 消息 Protobuf 结构工厂函数类型
type MessagePb3FactoryFunc func() proto.Message

var (
    messageCallbacks = make(map[int32]MessageCallbackFunc)
    messagePb3Factories = make(map[int32]MessagePb3FactoryFunc)
)

// RegisterMessageCallback 注册消息回调
func RegisterMessageCallback(msgType int32, callback MessageCallbackFunc) {
    messageCallbacks[msgType] = callback
}

// RegisterMessagePb3Factory 注册消息 Protobuf 结构工厂
func RegisterMessagePb3Factory(msgType int32, factory MessagePb3FactoryFunc) {
    messagePb3Factories[msgType] = factory
}

// GetMessageCallback 获取消息回调
func GetMessageCallback(msgType int32) MessageCallbackFunc {
    return messageCallbacks[msgType]
}

// GetMessagePb3 获取消息 Protobuf 结构
func GetMessagePb3(msgType int32) proto.Message {
    factory := messagePb3Factories[msgType]
    if factory == nil {
        return nil
    }
    return factory()
}
```

### 3.4 消息发送接口

**提供给其他系统使用的接口**（在 `server/service/gameserver/internel/gshare` 中实现）：

```go
// SendPlayerActorMessage 发送玩家Actor消息（如果玩家在线则立即处理，否则存入数据库）
func SendPlayerActorMessage(roleId uint64, msgType int32, msg proto.Message) error {
    // 1. 检查玩家是否在线（通过 PublicActor 的 IsOnline 方法）
    // 2. 如果在线，通过 SessionId 发送到 PlayerActor 处理
    // 3. 如果离线，存入数据库
}
```

**在线状态检查**：
- 通过 `PublicActor` 的 `IsOnline(roleId uint64) bool` 方法检查玩家是否在线
- 通过 `PublicActor` 的 `GetSessionId(roleId uint64) (string, bool)` 方法获取玩家的 SessionId
- 如果玩家在线，可以通过 `manager.GetPlayerRoleManager().Get(roleId)` 获取 PlayerRole，然后直接调用其方法处理消息
- 或者通过 `gshare.SendMessageAsync(sessionId, message)` 发送消息到 PlayerActor（推荐方式，符合 Actor 模型）

**内部消息处理**（在 `server/service/gameserver/internel/playeractor` 中实现）：

```go
// AddActorMessageMsg 添加Actor消息的内部消息
type AddActorMessageMsg struct {
    actor.BaseMessage
    MsgType int32
    MsgData []byte
}

// 在 PlayerRoleActor 中处理 AddActorMessageMsg
// 如果玩家在线，立即处理；如果离线，存入数据库
```

## 4. 实现步骤

### 4.1 数据库层实现

**文件**：`server/internal/database/player_actor_message.go`

**实现内容**：
1. 定义 `PlayerActorMessage` 结构体
2. 实现 `SavePlayerActorMessage` 函数
3. 实现 `LoadPlayerActorMessages` 函数（支持增量加载）
4. 实现 `DeletePlayerActorMessage` 函数
5. 实现 `DeletePlayerActorMessages` 函数
6. 实现 `GetPlayerActorMessageCount` 函数
7. 在 `server/internal/database/migrate.go` 中添加表迁移

### 4.2 消息注册机制实现

**文件**：`server/service/gameserver/internel/engine/message_registry.go`

**实现内容**（✅ 已完成）：
1. 定义 `MessageCallbackFunc` / `MessagePb3FactoryFunc`，约束回调签名
2. 借助 `sync.RWMutex` 管理注册表，支持热更新/注销（传入 `nil`）
3. `RegisterMessageCallback` / `RegisterMessagePb3Factory` / `GetMessageCallback` / `GetMessagePb3` 四个接口向外暴露
4. `GetMessagePb3` 内部调用工厂函数返回全新 proto 对象，避免复用导致的数据竞态

### 4.3 MessageSys 系统实现

**文件**：`server/service/gameserver/internel/playeractor/entitysystem/message_sys.go`

**实现内容**（✅ 已完成）：
1. `MessageSys` 继承 `BaseSystem`，在 `OnInit/OnRoleLogin/OnRoleReconnect` 中统一调用 `loadMsgFromDB`
2. `ensureOwner` 缓存 `iface.IPlayerRole`，避免多次从 ctx 解析
3. `loadMsgFromDB` 调用 `database.LoadPlayerActorMessages`，并将结果交给 `onLoadMsgFromDB`
4. `processMessage` 中按 msgType 获取 proto 工厂 → 反序列化 → 回调 `engine.GetMessageCallback`
5. 回调成功后删除消息（`database.DeletePlayerActorMessage`），失败保留以待下次重试
6. `GetMessageSys(ctx)` 便捷函数，方便后续系统联动
7. `init()` 注册 `SysMessage` 系统工厂，确保随 Actor 初始化加载

### 4.4 消息发送接口实现

**文件**：`server/service/gameserver/internel/gshare/message_sender.go`

**实现内容（✅ 已完成）**：
1. `SendPlayerActorMessage(roleId, msgType, proto.Message)`：自动序列化并判断玩家是否在线  
2. 若玩家在线：封装 `protocol.AddActorMessageMsg` → 通过 `gshare.PlayerMessageMsg` 发送到 PlayerActor 的邮箱  
3. 若玩家离线或发送失败：调用 `database.SavePlayerActorMessage` 落库，等待下次上线由 MessageSys 回放  
4. 统一依赖 `manager.GetPlayerRole`、`actor.NewBaseMessage`，避免业务系统直接触及 Actor 细节

**文件**：`server/service/gameserver/internel/playeractor/entity/player_network.go`

**实现内容（✅ 已完成）**：
1. 新增 `handlePlayerMessageMsg`，在 Actor 主线程内解析 `AddActorMessageMsg`  
2. 找到当前 PlayerRole，调用 `entitysystem.DispatchPlayerMessage` 执行消息回调  
3. 回调失败或玩家瞬时离线时，自动回退到 `database.SavePlayerActorMessage`，确保消息不丢失  
4. 在 `gevent.OnSrvStart` 钩子中注册 `gshare.PlayerMessageMsg` 处理器

### 4.5 Proto 定义

**文件**：`proto/csproto/system.proto`（✅ 已完成）

- 新增 `SysMessage = 20`，并调整 `SysIdMax = 21`

**文件**：`proto/csproto/rpc.proto`（✅ 已完成）

- 新增内部消息 `AddActorMessageMsg { role_id, msg_type, msg_data }`，供 Actor 传递消息使用  
- 重新执行 `proto/genproto.sh`，同步生成 `server/internal/protocol/rpc.pb.go`

### 4.6 系统注册

**文件**：`server/service/gameserver/internel/playeractor/entitysystem/message_sys.go`

**实现内容（✅ 已完成）**：
1. `init()` 中注册 `SysMessage` 系统工厂  
2. 对外提供 `DispatchPlayerMessage`，供在线消息以及离线回放共用  
3. `processMessage` 与 `handlePlayerMessageMsg` 均复用该入口，避免两套逻辑

## 5. 使用示例

### 5.1 注册消息处理回调

```go
// 在需要处理消息的系统中注册回调
func init() {
    // 注册消息回调
    engine.RegisterMessageCallback(int32(protocol.XXXMsgType), handleXXXMessage)
    
    // 注册消息 Protobuf 结构工厂
    engine.RegisterMessagePb3Factory(int32(protocol.XXXMsgType), func() proto.Message {
        return &protocol.XXXMessage{}
    })
}

func handleXXXMessage(owner iface.IPlayerRole, msg proto.Message) error {
    xxxMsg := msg.(*protocol.XXXMessage)
    // 处理消息逻辑
    return nil
}
```

### 5.2 发送消息给玩家

```go
// 发送消息给玩家（如果玩家在线则立即处理，否则存入数据库）
msg := &protocol.XXXMessage{
    // ... 消息内容
}
err := gshare.SendPlayerActorMessage(roleId, int32(protocol.XXXMsgType), msg)
if err != nil {
    log.Errorf("send player actor message failed: %v", err)
}
```

## 6. 注意事项

### 6.1 架构约束

1. **Actor 模型**：所有消息处理必须在 PlayerActor 主线程中执行，禁止创建额外的 goroutine
2. **无锁设计**：MessageSys 系统直接使用数据库，不维护内存缓存（避免并发问题）
3. **时间访问规范**：所有时间访问必须使用 `server/internal/servertime`，禁止直接调用 `time.Now()`

### 6.2 数据持久化

1. **消息存储**：消息以 Protobuf 序列化后的字节数组形式存储
2. **消息清理**：建议定期清理过期消息（例如：超过7天的消息）
3. **消息数量限制**：建议对每个玩家的消息数量进行限制（例如：最多1000条）

### 6.3 性能考虑

1. **增量加载**：支持增量加载消息（通过 `afterMsgId` 参数），避免重复加载
2. **批量处理**：加载消息后批量处理，避免频繁的数据库操作
3. **异步删除**：消息处理完成后异步删除，避免阻塞主流程

### 6.4 错误处理

1. **消息反序列化失败**：记录错误日志，跳过该消息，继续处理下一条
2. **消息回调未注册**：记录警告日志，跳过该消息
3. **数据库操作失败**：记录错误日志，但不影响消息处理流程

## 7. 测试建议

### 7.1 单元测试

1. 测试消息存储和加载
2. 测试消息处理回调
3. 测试消息删除
4. 测试增量加载

### 7.2 集成测试

1. 测试玩家上线时消息加载
2. 测试玩家重连时消息加载
3. 测试玩家离线时消息存储
4. 测试消息处理流程

### 7.3 压力测试

1. 测试大量消息的存储和加载性能
2. 测试并发场景下的消息处理
3. 测试消息清理性能

## 8. 后续优化

1. **消息优先级**：支持消息优先级，高优先级消息优先处理
2. **消息过期时间**：支持消息过期时间，过期消息自动清理
3. **消息分类**：支持消息分类，不同类型消息可以有不同的处理策略
4. **消息统计**：支持消息统计，记录消息处理情况

## 9. 关键代码位置

### 9.1 数据库层
- `server/internal/database/player_actor_message.go`：数据库操作
- `server/internal/database/migrate.go`：表迁移

### 9.2 消息注册机制
- `server/service/gameserver/internel/engine/message_registry.go`：消息注册和获取

### 9.3 MessageSys 系统
- `server/service/gameserver/internel/playeractor/entitysystem/message_sys.go`：消息系统实现

### 9.4 消息发送接口
- `server/service/gameserver/internel/gshare/message_sender.go`：消息发送接口
- `server/service/gameserver/internel/playeractor/adapter.go`：PlayerActor 消息处理

### 9.5 Proto 定义
- `proto/csproto/system.proto`：系统ID定义
- `proto/csproto/rpc.proto`：内部消息定义（如果需要）

## 10. 开发检查清单

- [x] 数据库表设计和迁移
- [x] 数据库操作函数实现
- [x] 消息注册机制实现
- [x] MessageSys 系统实现
- [ ] 消息发送接口实现
- [ ] PlayerActor 消息处理
- [x] Proto 定义更新
- [x] 系统注册
- [ ] 单元测试
- [ ] 集成测试
- [x] 文档更新（服务端开发进度文档.md）

## 11. 参考文件

- `server/server/gameserver/logicworker/actorsystem/messagesys.go`：参考实现
- `server/server/gameserver/gshare/offlinemsgid.go`：离线消息ID定义
- `server/service/gameserver/internel/playeractor/entitysystem/base_sys.go`：系统基类
- `server/service/gameserver/internel/playeractor/entitysystem/sys_mgr.go`：系统管理器
- `server/internal/database/offline_message.go`：现有离线消息系统（仅用于聊天）

