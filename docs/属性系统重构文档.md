# 属性系统重构文档

更新时间：2025-01-XX  
责任人：开发团队

## 1. 文档目的

本文档旨在梳理 `server/server` 中 gameserver 和 fightsrv 的属性系统实现，并基于此制定 `server/service` 中 gameserver 和 dungeonserver 属性系统的重构方案。

## 2. server/server 属性系统架构分析

### 2.1 GameServer 属性系统 (gameserver/logicworker/actorsystem/attr_sys.go)

#### 2.1.1 核心数据结构

```go
type AttrSys struct {
    owner iface.IPlayer
    
    // 非战斗属性（如等级、经验、金币等）
    extraAttr *attrcalc.ExtraAttrCalc
    
    // 战斗属性（从战斗服同步回来的最终属性）
    fightAttr *attrcalc.FightAttrCalc
    
    // 各系统属性（每个系统一个计算器）
    sysAttr        [attrdef.SysEnd]*attrcalc.FightAttrCalc
    
    // 各系统加成属性（百分比加成）
    sysAddRateAttr [attrdef.SysEnd]*attrcalc.FightAttrCalc
    
    // 脏标记
    mask             *bitset.BitSet              // 需要同步的系统属性
    extraUpdateMask  *bitset.BitSet              // 需要同步的非战斗属性
    bSysAttrChange   bool                        // 系统属性是否变化
    bExtraAttrChange bool                        // 非战斗属性是否变化
    
    // 各系统战力
    sysPowerMap map[uint32]int64
}
```

#### 2.1.2 核心功能

1. **系统属性管理**
   - `ResetSysAttr(sysId)`: 重置指定系统的属性，通过回调函数 `engine.GetAttrCalcFn(sysId)` 计算属性
   - `sysAttr[sysId]`: 每个系统维护一个独立的 `FightAttrCalc`，存储该系统的属性贡献

2. **加成属性计算**
   - `calcTotalSysAddRate()`: 汇总所有系统属性，然后通过 `engine.EachAttrCalcFn` 遍历所有加成计算回调，计算各系统的加成属性
   - `sysAddRateAttr[sysId]`: 每个系统维护一个独立的加成属性计算器

3. **属性同步**
   - `checkSync()`: 
     - 计算各系统属性加成
     - 构建 `SyncSysAttr` 消息，包含各系统属性和总加成属性
     - 计算各系统战力并触发事件
     - 通过 `CallActorFunc(actorfuncid.UpdateSysAttr, &msg)` 同步到战斗服
   - `LogicRun()`: 处理非战斗属性的同步，通过 `CallActorFunc(actorfuncid.UpdateExtraAttr, &msg)` 同步到战斗服

4. **战力计算**
   - 每个系统单独计算战力：`attrcalc.CalcByJobConvertAttackAndDefendGetFightValue(singleCalc, job)`
   - 维护 `sysPowerMap` 用于前端展示

5. **属性推送**
   - `ReConnectSendSysAttr()`: 重连时根据配置推送系统属性到前端

#### 2.1.3 属性计算流程

```
系统变化触发 ResetSysAttr(sysId)
    ↓
调用 engine.GetAttrCalcFn(sysId) 回调计算系统属性
    ↓
设置 sysAttr[sysId] 并标记脏标记
    ↓
RunOne() 中调用 checkSync()
    ↓
calcTotalSysAddRate() 计算各系统加成属性
    ↓
构建 SyncSysAttr 消息（包含各系统属性和总加成属性）
    ↓
计算各系统战力并触发事件
    ↓
通过 CallActorFunc 同步到战斗服
```

### 2.2 FightServer 属性系统 (fightsrv/entitysystem/attr_sys.go)

#### 2.2.1 核心数据结构

```go
type AttrSys struct {
    owner iface.IEntity
    
    // 非战斗属性
    extraAttr       *attrcalc.ExtraAttrCalc
    
    // 战斗属性（最终计算的属性）
    fightAttr       *attrcalc.FightAttrCalc
    
    // 属性集合（管理各系统的增量和减量属性）
    attrSet          *attrcalc.AttrSet
    
    // 加成属性计算器
    addRateAttrsCalc *attrcalc.FightAttrCalc
    
    // 脏标记
    extraUpdateMask *bitset.BitSet
    bNeedReset      bool
    bInitFinish     bool
}
```

#### 2.2.2 AttrSet 结构

```go
type AttrSet struct {
    // 各系统的增量属性（当前和上次）
    lastIncAttrs [attrdef.SysEnd]*FightAttrCalc
    curIncAttrs  [attrdef.SysEnd]*FightAttrCalc
    
    // 各系统的减量属性（当前和上次）
    lastDecAttrs [attrdef.SysEnd]*FightAttrCalc
    curDecAttrs  [attrdef.SysEnd]*FightAttrCalc
}
```

#### 2.2.3 核心功能

1. **属性初始化**
   - `InitData(create *pb3.CreateActorData)`: 从 `CreateActorData` 初始化属性
     - 遍历 `create.Attrs`，将各系统属性添加到 `attrSet.GetIncAttr(sysId)`
     - 将 `create.AddRateAttr` 设置到 `addRateAttrsCalc`
     - 设置 `create.ExtraAttrs` 到 `extraAttr`

2. **属性重置和计算**
   - `ResetProperty()`:
     - 通过 `attrSet.ResetProperty(calc)` 汇总所有系统的增量和减量属性
     - 加上 `addRateAttrsCalc` 加成属性
     - 应用属性转换（如 Attack → AttackWu/AttackMo）
     - 应用百分比加成（通过 `AddRateByCalc`）
     - 计算战力（仅玩家）
     - 处理 HP/MP 的等比变化
     - 更新 `fightAttr` 并广播属性变化
     - 同步回逻辑服（`SyncFightAndAttr`）

3. **系统属性更新**
   - `ResetSysAttr(sysId)`: 
     - 通过 `engine.GetIncAttrCalcFn(sysId)` 和 `engine.GetDecAttrCalcFn(sysId)` 回调计算增量和减量属性
     - 设置到 `attrSet` 并标记需要重置

4. **属性同步**
   - `updateSysAttr()`: 处理从逻辑服同步的系统属性（`SyncSysAttr`）
     - 将各系统属性添加到 `attrSet.GetIncAttr(sysId)`
     - 更新 `addRateAttrsCalc`
     - 标记需要重置
   - `updateExtraAttr()`: 处理从逻辑服同步的非战斗属性（`SyncExtraAttr`）

5. **属性广播**
   - `CheckAndSyncProp()`: 检查非战斗属性变化并广播
   - `BroAllFightAttr()`: 广播所有战斗属性

#### 2.2.4 属性计算流程

```
从逻辑服收到 SyncSysAttr
    ↓
updateSysAttr() 更新 attrSet 和 addRateAttrsCalc
    ↓
标记 bNeedReset = true
    ↓
RunOne() 中调用 ResetProperty()
    ↓
attrSet.ResetProperty() 汇总所有系统属性
    ↓
加上 addRateAttrsCalc 加成属性
    ↓
应用属性转换和百分比加成
    ↓
计算最终属性并更新 fightAttr
    ↓
广播属性变化（客户端和场景）
    ↓
同步回逻辑服（SyncFightAndAttr）
```

## 3. server/service 属性系统现状分析

### 3.1 GameServer 属性系统 (gameserver/internel/playeractor/entitysystem/attr_sys.go)

#### 3.1.1 当前实现

```go
type AttrSys struct {
    *BaseSystem
    // 属性数据：key为SaAttrSys枚举值，value为该系统的属性列表
    attrDataMap map[uint32]*protocol.AttrVec
    // 脏标记：标记需要重算的系统
    dirtySystems map[uint32]bool
    // 属性计算器注册表
    calculators map[uint32]attrcalc.Calculator
}
```

#### 3.1.2 缺失功能

1. ❌ **缺少系统属性存储结构**
   - 当前只有 `attrDataMap`，没有类似 `sysAttr` 的数组结构
   - 无法区分各系统的属性贡献

2. ❌ **缺少加成属性计算**
   - 没有 `sysAddRateAttr` 结构
   - 没有 `calcTotalSysAddRate()` 方法
   - 无法计算百分比加成属性

3. ❌ **缺少战力计算**
   - 没有系统战力计算
   - 没有 `sysPowerMap` 维护

4. ❌ **缺少属性推送机制**
   - 没有重连时的属性推送
   - 没有属性推送配置支持

5. ❌ **缺少 ResetSysAttr 机制**
   - 没有通过回调函数计算系统属性的机制
   - 无法在系统变化时触发属性重算

6. ❌ **属性同步不完整**
   - 当前只同步到 DungeonServer，缺少加成属性的计算和同步

### 3.2 DungeonServer 属性系统 (dungeonserver/internel/entitysystem/attr_sys.go)

#### 3.2.1 当前实现

```go
type AttrSys struct {
    owner       iface.IEntity
    attrSet     *attrcalc.AttrSet
    fightAttr   *attrcalc.FightAttrCalc
    extraAttr   *attrcalc.ExtraAttrCalc
    addRateAttr *attrcalc.FightAttrCalc
    dirty       bool
    lastMaxHP   attrdef.AttrValue
}
```

#### 3.2.2 缺失功能

1. ❌ **缺少属性计算器注册管理器**
   - 没有类似 GameServer 的 `attrcalc/bus.go` 注册机制
   - 无法注册怪物属性计算器（如 `MonsterBaseProperty`）
   - 无法注册 Buff 系统属性计算器
   - 缺少 `ResetSysAttr(sysId)` 方法，无法通过注册管理器触发属性重算

2. ❌ **缺少本地系统属性计算能力**
   - 当前只能接收 GameServer 下发的属性（`ApplySyncData`）
   - 无法计算战斗服本地系统的属性（怪物基础属性、Buff 属性等）
   - 属性汇总逻辑不完整：应该是 `GameServer属性 + Buff属性 + 其他战斗服系统属性`

3. ❌ **缺少增量/减量属性计算回调**
   - 参考 `jjyz/server/fightsrv/engine/attr_calc.go`，需要支持 `RegIncAttrCalcFn` 和 `RegDecAttrCalcFn`
   - 当前 `AttrSys` 没有 `ResetSysAttr` 方法调用这些回调

4. ⚠️ **属性汇总逻辑需要明确**
   - `RoleEntity` 的属性应该是：`GameServer提供的属性 + Buff提供的属性 + 后续扩展只存在战斗服其他系统的属性`
   - 需要区分哪些属性来自 GameServer，哪些来自战斗服本地系统

## 4. 重构方案

### 4.1 重构目标

1. **GameServer 属性系统**
   - 实现系统属性存储结构（类似 `sysAttr` 数组）
   - 实现加成属性计算机制
   - 实现战力计算和系统战力映射
   - 实现属性推送机制
   - 实现 `ResetSysAttr` 机制
   - 完善属性同步到 DungeonServer

2. **DungeonServer 属性系统**
   - 实现 `AttrSet` 结构管理属性集合
   - 实现加成属性计算和应用
   - 实现属性重置和计算机制
   - 实现属性同步处理（从 GameServer）
   - 实现属性广播机制
   - 实现属性初始化机制

### 4.2 重构步骤

#### 阶段一：基础结构重构

**4.2.1 GameServer 属性系统基础结构**

1. **添加核心数据结构**
   ```go
   type AttrSys struct {
       *BaseSystem
       
       // 各系统属性（每个系统一个计算器）
       sysAttr        map[uint32]*attrcalc.FightAttrCalc
       
       // 各系统加成属性
       sysAddRateAttr map[uint32]*attrcalc.FightAttrCalc
       
       // 非战斗属性
       extraAttr *attrcalc.ExtraAttrCalc
       
       // 战斗属性（从 DungeonServer 同步回来的）
       fightAttr *attrcalc.FightAttrCalc
       
       // 脏标记
       dirtySystems map[uint32]bool
       extraUpdateMask *bitset.BitSet
       bSysAttrChange bool
       bExtraAttrChange bool
       
       // 各系统战力
       sysPowerMap map[uint32]int64
       
       // 属性计算器注册表（保留现有）
       calculators map[uint32]attrcalc.Calculator
   }
   ```

2. **实现 ResetSysAttr 方法**
   ```go
   func (as *AttrSys) ResetSysAttr(sysId uint32) {
       // 1. 获取或创建系统属性计算器
       calc := as.sysAttr[sysId]
       if calc == nil {
           calc = attrcalc.NewFightAttrCalc()
           as.sysAttr[sysId] = calc
       }
       calc.Reset()
       
       // 2. 通过计算器回调计算属性
       calculator := as.calculators[sysId]
       if calculator != nil {
           attrs := calculator.CalculateAttrs(ctx)
           for _, attr := range attrs {
               calc.AddValue(attr.Type, attr.Value)
           }
       }
       
       // 3. 标记脏标记
       as.dirtySystems[sysId] = true
       as.bSysAttrChange = true
   }
   ```

3. **实现加成属性计算**
   ```go
   func (as *AttrSys) calcTotalSysAddRate(ctx context.Context) {
       // 1. 汇总所有系统属性
       totalSysCalc := attrcalc.NewFightAttrCalc()
       for _, calc := range as.sysAttr {
           if calc != nil {
               totalSysCalc.AddCalc(calc)
           }
       }
       
       // 2. 遍历所有加成计算回调（需要注册机制）
       // TODO: 实现加成计算回调注册机制
       // engine.EachAttrCalcFn(func(sysId uint32, cb AddRateCalcCBFn) {
       //     calc := as.sysAddRateAttr[sysId]
       //     if calc == nil {
       //         calc = attrcalc.NewFightAttrCalc()
       //         as.sysAddRateAttr[sysId] = calc
       //     }
       //     calc.Reset()
       //     cb(owner, totalSysCalc, calc)
       // })
   }
   ```

4. **实现属性同步方法**
   ```go
   func (as *AttrSys) checkSync(ctx context.Context) {
       if !as.bSysAttrChange {
           return
       }
       
       // 1. 计算各系统属性加成
       as.calcTotalSysAddRate(ctx)
       
       // 2. 构建同步数据
       syncData := &protocol.SyncAttrData{
           AttrData: make(map[uint32]*protocol.AttrVec),
           AddRateAttr: &protocol.AttrVec{},
       }
       
       // 3. 收集各系统属性
       for sysId, calc := range as.sysAttr {
           if calc == nil {
               continue
           }
           attrs := make([]*protocol.AttrSt, 0)
           calc.DoRange(func(attrType uint32, value int64) {
               attrs = append(attrs, &protocol.AttrSt{
                   Type: attrType,
                   Value: value,
               })
           })
           if len(attrs) > 0 {
               syncData.AttrData[sysId] = &protocol.AttrVec{Attrs: attrs}
           }
       }
       
       // 4. 收集加成属性
       totalAddRateCalc := attrcalc.NewFightAttrCalc()
       for _, calc := range as.sysAddRateAttr {
           if calc != nil {
               totalAddRateCalc.AddCalc(calc)
           }
       }
       addRateAttrs := make([]*protocol.AttrSt, 0)
       totalAddRateCalc.DoRange(func(attrType uint32, value int64) {
           addRateAttrs = append(addRateAttrs, &protocol.AttrSt{
               Type: attrType,
               Value: value,
           })
       })
       if len(addRateAttrs) > 0 {
           syncData.AddRateAttr = &protocol.AttrVec{Attrs: addRateAttrs}
       }
       
       // 5. 计算各系统战力
       as.calcSysPowerMap(ctx)
       
       // 6. 同步到 DungeonServer
       as.syncAttrsToDungeonServer(ctx, syncData)
       
       // 7. 清空脏标记
       as.bSysAttrChange = false
       as.dirtySystems = make(map[uint32]bool)
   }
   ```

5. **实现战力计算**
   ```go
   func (as *AttrSys) calcSysPowerMap(ctx context.Context) {
       playerRole, err := GetIPlayerRoleByContext(ctx)
       if err != nil {
           return
       }
       
       job := playerRole.GetJob() // 需要从角色数据获取职业
       as.sysPowerMap = make(map[uint32]int64)
       
       for sysId, calc := range as.sysAttr {
           if calc == nil {
               continue
           }
           singleCalc := attrcalc.NewFightAttrCalc()
           singleCalc.AddCalc(calc)
           
           // 加上该系统的加成属性
           addRateCalc := as.sysAddRateAttr[sysId]
           if addRateCalc != nil {
               singleCalc.AddCalc(addRateCalc)
           }
           
           // 计算战力（需要实现 CalcByJobConvertAttackAndDefendGetFightValue）
           power := attrcalc.CalcByJobConvertAttackAndDefendGetFightValue(singleCalc, int8(job))
           as.sysPowerMap[sysId] = power
       }
       
       // 触发战力变化事件
       // TODO: 触发事件
   }
   ```

#### 阶段一落地情况（2025-11-27）

- **GameServer AttrSys 基础设施**（`server/service/gameserver/internel/playeractor/entitysystem/attr_sys.go`）  
  已实现系统级缓存、差异化同步（`calculateSystemAttr`/`RunOne`）、`ResetSysAttr` 公开入口及系统战力映射；`SyncAttrData` 现包含 `AddRateAttr`，为后续加成计算预留通道。
- **DungeonServer AttrSys 聚合能力**（`server/service/dungeonserver/internel/entitysystem/attr_sys.go`）  
  新增 `ApplySyncData` / `ensureAggregated`，可直接消费 GameServer 下发的系统属性与加成属性，移除旧版手工叠加逻辑。
- **角色实体链路精简**（`server/service/dungeonserver/internel/entity/rolest.go`）  
  `RoleEntity` 不再维护 `attrDataMap`，改为将 `SyncAttrData` 交由 AttrSys 处理，`UpdateAttrs` 幂等可重入。
- **协议扩展**（`proto/csproto/attr_def.proto`、`server/internal/protocol/attr_def.pb.go`）  
  `SyncAttrData` 新增 `add_rate_attr` 字段，已使用 `protoc.exe` + `gofmt` 同步生成代码。

#### 阶段二落地情况（2025-11-27）

- **加成计算注册总线**：`attrcalc/add_rate_bus.go` 提供 `RegisterAddRate/CloneAddRateCalculators`，`AttrSys.calcTotalSysAddRate` 自动汇总 `sysAttr` → `sysAddRateAttr`，并示范实现 `levelAddRateCalculator`（等级提升提升 HP/MP 回复）。
- **属性推送链路**：`proto/sc.proto` 的 `S2CAttrDataReq` 携带 `SyncAttrData + sys_power_map`；GameServer 在属性变更、首次登录与重连时使用 `pushAttrDataToClient` 将最新属性/战力推送给客户端。
- **重连回补**：`PlayerRole.OnReconnect` 调用 `AttrSys.PushFullAttrData`，确保客户端在阶段二后总能收到权威属性快照。

#### 阶段三落地情况（2025-11-27）

- **Dungeon AttrSys 重构**：`server/service/dungeonserver/internel/entitysystem/attr_sys.go` 采用共享 `attrcalc.AttrSet` + `FightAttrCalc`，支持增/减属性分摊、HP 等比回调、加成叠加以及 `S2CAttrData` 实时推送，告别一次性聚合的旧实现。
- **配置驱动战力与推送**：`config/attr_config.json` 的 `power/push` 分区由 `server/internal/attrpower` 与 `attrpush` 解析，统一 Game/Dungeon 的战力计算与推送策略（可指定推送系统、是否附带战力）。
- **多源加成计算**：`config/attr_config.json.add_rate` 配置化 Level/Equip 两类加成；`levelAddRateCalculator` 和新加入的 `equipAddRateCalculator` 通过注册总线注入，外部系统只需描述加成规则即可。
- **端到端验证**：新增《`docs/属性系统阶段三联调记录.md`》，记录登录 → 属性变动（装备精炼/升级）→ 重连的预生产检查步骤，确保客户端已稳定接收 `S2CAttrData`。

**4.2.2 DungeonServer 属性系统基础结构**

1. ✅ **已实现 AttrSet 结构**
   - 在 `server/internal/attrcalc/attr_set.go` 中已实现 `AttrSet` 结构
   - 支持增量和减量属性分离管理

2. ✅ **已重构 AttrSys 结构**
   ```go
   type AttrSys struct {
       owner       iface.IEntity
       attrSet     *attrcalc.AttrSet
       fightAttr   *attrcalc.FightAttrCalc
       extraAttr   *attrcalc.ExtraAttrCalc
       addRateAttr *attrcalc.FightAttrCalc
       dirty       bool
       lastMaxHP   attrdef.AttrValue
   }
   ```

3. ✅ **已实现属性同步**  
   GameServer 下发的 `SyncAttrData` 通过 `ApplySyncData` 写入 `attrSet`（增量）和 `addRateAttr`，本地修改只需调用 `attrSet.GetIncAttr/GetDecAttr` 或 `MarkDirty`。所有写操作都会触发 `ResetProperty` 懒计算。

4. ✅ **已实现 ResetProperty 流程**
   ```go
   func (as *AttrSys) ResetProperty() {
       if !as.dirty {
           return
       }
       as.dirty = false
       calc := attrcalc.NewFightAttrCalc()
       as.attrSet.ResetProperty(calc)
       calc.AddCalc(as.addRateAttr)
       attrcalc.ApplyConversions(temp)
       attrcalc.ApplyPercentages(temp)
       as.applyFightAttr(calc)      // HP/MP 等比回调
       as.broadcastAttrData()      // 推送 S2CAttrData + 战力
   }
   ```

5. ✅ **已实现属性推送与战力计算**
   - `buildSyncAttrData` 直接复用 `attrSet.PackToMap`，将每个系统的增量导出为 `SyncAttrData.AttrData`，加成属性写入 `AddRateAttr`。
   - `broadcastAttrData` 通过实体的 `SendProtoMessage` 推送 `S2CAttrDataReq`，战力由共享的 `attrpower.CalcPower` + `attr_config.json.power` 决定，Map key 统一使用 `SaAttrSysNil`。

**4.2.3 DungeonServer 属性系统完善（待实现）**

**问题分析：**
- 当前 DungeonServer 的 `AttrSys` 只能接收 GameServer 下发的属性，无法计算战斗服本地系统的属性（如怪物基础属性、Buff 属性等）
- 参考 `jjyz/server/fightsrv/entitysystem/attr_sys.go` 和 `jjyz/server/fightsrv/engine/attr_calc.go`，需要实现属性计算器注册管理器
- `RoleEntity` 的属性应该是：`GameServer提供的属性 + Buff提供的属性 + 其他战斗服系统属性`

**实现步骤：**

1. **创建属性计算器注册管理器**
   - 在 `server/service/dungeonserver/internel/entitysystem/attrcalc/` 目录下创建 `bus.go`
   - 参考 `server/service/gameserver/internel/playeractor/entitysystem/attrcalc/bus.go`，但接口不同：
     ```go
     // DungeonServer 使用增量/减量回调，直接操作 FightAttrCalc
     type IncAttrCalcFn func(owner iface.IEntity, calc *attrcalc.FightAttrCalc)
     type DecAttrCalcFn func(owner iface.IEntity, calc *attrcalc.FightAttrCalc)
     
     func RegIncAttrCalcFn(sysId uint32, fn IncAttrCalcFn)
     func RegDecAttrCalcFn(sysId uint32, fn DecAttrCalcFn)
     func GetIncAttrCalcFn(sysId uint32) IncAttrCalcFn
     func GetDecAttrCalcFn(sysId uint32) DecAttrCalcFn
     ```

2. **在 AttrSys 中实现 ResetSysAttr 方法**
   ```go
   func (as *AttrSys) ResetSysAttr(sysId uint32) {
       // 1. 获取增量计算回调
       if incFn := attrcalc.GetIncAttrCalcFn(sysId); incFn != nil {
           calc := as.attrSet.GetIncAttr(sysId, true, true)
           incFn(as.owner, calc)
           as.MarkDirty()
       }
       
       // 2. 获取减量计算回调
       if decFn := attrcalc.GetDecAttrCalcFn(sysId); decFn != nil {
           calc := as.attrSet.GetDecAttr(sysId, true, true)
           decFn(as.owner, calc)
           as.MarkDirty()
       }
   }
   ```

3. **实现怪物基础属性计算器**
   - 在 `server/service/dungeonserver/internel/entity/monster.go` 中实现 `monsterBaseProperty` 函数
   - 参考 `jjyz/server/fightsrv/entity/monster.go:1315`，从怪物配置表读取基础属性
   - 在 `init()` 中注册：`attrcalc.RegIncAttrCalcFn(attrdef.MonsterBaseProperty, monsterBaseProperty)`

4. **实现 Buff 系统属性计算器**
   - 在 `server/service/dungeonserver/internel/entitysystem/buff_sys.go` 中实现 Buff 属性计算
   - 遍历实体的所有 Buff，汇总属性加成
   - 注册为系统属性计算器：`attrcalc.RegIncAttrCalcFn(attrdef.SaBuff, buffAttrCalc)`

5. **属性汇总逻辑明确**
   - `RoleEntity` 的属性来源：
     - GameServer 属性：通过 `ApplySyncData` 写入 `attrSet`（系统ID 为 GameServer 的系统ID）
     - Buff 属性：通过 `ResetSysAttr(attrdef.SaBuff)` 计算，写入 `attrSet`（系统ID 为 `attrdef.SaBuff`）
     - 其他战斗服系统属性：通过各自的 `ResetSysAttr` 计算，写入 `attrSet`
   - `ResetProperty` 会汇总所有系统的属性（包括 GameServer 和战斗服本地系统）

6. **提取公共工具包**
   - 将 `server/service/gameserver/internel/playeractor/entitysystem/attrcalc/bus.go` 的通用逻辑提取到 `server/internal/attrcalc/bus.go`
   - GameServer 和 DungeonServer 各自实现适配层：
     - GameServer: `server/service/gameserver/internel/playeractor/entitysystem/attrcalc/bus.go` 使用 `SysAttrCalculator` 接口
     - DungeonServer: `server/service/dungeonserver/internel/entitysystem/attrcalc/bus.go` 使用 `IncAttrCalcFn/DecAttrCalcFn` 回调

#### 阶段二：功能完善

**4.2.3 属性计算器注册机制**

1. **实现加成计算回调注册**
   - 在 `server/service/gameserver/internel/playeractor/entitysystem/attrcalc` 中添加注册机制
   - 参考 `server/server` 的 `engine.RegAttrAddRateCalcFn`

2. **实现系统属性计算回调**
   - 完善 `ResetSysAttr` 中的回调机制
   - 支持增量和减量属性计算（DungeonServer 需要）

**4.2.4 属性同步协议**

1. **完善 GameServer → DungeonServer 同步**
   - 确保 `SyncAttrData` 包含 `AddRateAttr`
   - 实现增量同步（只同步变化的系统）

2. **实现 DungeonServer → GameServer 同步**
   - 实现 `SyncFightAndAttr` 协议
   - 同步最终战斗属性和战力

**4.2.5 属性广播机制**

1. **实现属性变化检测**
   - 在 `ResetProperty` 中检测属性变化
   - 区分需要广播和需要同步的属性

2. **实现属性广播**
   - 广播到场景中的其他实体
   - 同步到客户端

#### 阶段三：高级功能

**4.2.6 战力计算**

1. **实现战力计算公式**
   - 参考 `server/server/base/attrcalc/fight_attr.go` 的 `GetFightValue` 和 `CalcByJobConvertAttackAndDefendGetFightValue`
   - 需要配置表支持（属性权重）

2. **实现系统战力映射**
   - 维护各系统战力
   - 支持前端展示

**4.2.7 属性推送机制**

1. **实现属性推送配置**
   - 支持配置哪些属性需要推送到前端
   - 支持系统属性聚合推送

2. **实现重连属性推送**
   - 重连时根据配置推送属性

## 5. 关键代码位置

### 5.1 server/server 参考代码

- **GameServer 属性系统**: `server/server/gameserver/logicworker/actorsystem/attr_sys.go`
- **FightServer 属性系统**: `server/server/fightsrv/entitysystem/attr_sys.go`
- **属性计算器**: 
  - `server/server/base/attrcalc/fight_attr.go`
  - `server/server/base/attrcalc/extra_attr.go`
  - `server/server/base/attrcalc/attr_set.go`
- **属性定义**: `server/server/base/custom_id/attrdef/`

### 5.2 server/service 需要重构的代码

- **GameServer 属性系统**: `server/service/gameserver/internel/playeractor/entitysystem/attr_sys.go`
- **DungeonServer 属性系统**: `server/service/dungeonserver/internel/entitysystem/attr_sys.go`
- **属性计算器**: 
  - `server/internal/attrcalc/attrcalc.go`
  - `server/internal/attrcalc/extraattrcalc.go`
  - 需要新增: `server/internal/attrcalc/attr_set.go`
- **属性定义**: `server/internal/attrdef/attrdef.go`

## 6. 注意事项

1. **属性计算器接口统一**
   - GameServer 和 DungeonServer 的属性计算器接口需要统一
   - 确保属性计算逻辑一致

2. **属性同步协议**
   - 确保 `SyncAttrData` 协议包含所有必要字段
   - 支持增量同步以提高性能

3. **属性转换规则**
   - 需要明确属性转换规则（如 Attack → AttackWu/AttackMo）
   - 需要配置表支持

4. **百分比加成计算**
   - 需要明确加成计算的顺序和规则
   - 需要配置表支持加成系数

5. **战力计算公式**
   - 需要配置表支持属性权重
   - 需要支持不同职业的战力计算

6. **性能优化**
   - 属性计算应该只在脏标记时进行
   - 属性同步应该只同步变化的属性
   - 考虑属性计算的缓存机制

7. **测试验证**
   - 需要充分测试属性计算的正确性
   - 需要测试属性同步的完整性
   - 需要测试战力计算的准确性

## 7. 重构检查清单

### GameServer 属性系统

- [x] 添加 `sysAttr` 和 `sysAddRateAttr` 结构
- [x] 实现 `ResetSysAttr` 方法
- [x] 实现 `calcTotalSysAddRate` 方法
- [x] 实现 `checkSync` 方法（RunOne 差异化同步）
- [x] 实现 `calcSysPowerMap` 方法
- [x] 实现属性推送机制
- [x] 完善属性同步到 DungeonServer
- [x] 添加属性计算器注册机制
- [x] 添加加成计算回调注册机制

### DungeonServer 属性系统

- [x] 实现 `AttrSet` 结构
- [x] 重构 `AttrSys` 结构
- [x] 实现 `InitData` / `ApplySyncData` 流程
- [x] 实现 `ResetProperty` 方法
- [x] 实现属性广播机制（DungeonServer 推送 `S2CAttrData`）
- [x] 实现同步回 GameServer 机制
- [x] 添加属性转换和百分比加成应用
- [x] 添加属性变化检测（`MarkDirty` + 懒计算）
- [x] **创建属性计算器注册管理器**（`server/service/dungeonserver/internel/entitysystem/attrcalc/bus.go`）
- [x] **在 AttrSys 中实现 ResetSysAttr 方法**
- [x] **实现怪物基础属性计算器并注册**
- [x] **实现 Buff 系统属性计算器并注册**
- [ ] **提取公共工具包供 GameServer 和 DungeonServer 使用**（低优先级，可后续优化）

### 公共功能

- [x] 实现战力计算公式
- [x] 实现属性推送配置
- [x] 完善属性同步协议（`S2CAttrData` 拓展 + Dungeon 推送）
- [x] 添加属性计算器接口统一
- [ ] 添加测试用例

## 8. DungeonServer 属性系统完善方案（待实现）

### 8.1 问题分析

当前 DungeonServer 的 `AttrSys` 存在以下问题：

1. **只能接收 GameServer 属性**：当前实现只能通过 `ApplySyncData` 接收 GameServer 下发的属性，无法计算战斗服本地系统的属性
2. **缺少属性计算器注册管理器**：没有类似 GameServer 的 `attrcalc/bus.go` 注册机制，无法注册怪物属性计算器、Buff 属性计算器等
3. **缺少 ResetSysAttr 方法**：无法通过注册管理器触发属性重算
4. **属性汇总逻辑不完整**：`RoleEntity` 的属性应该是 `GameServer提供的属性 + Buff提供的属性 + 其他战斗服系统属性`，但当前只能处理 GameServer 属性

### 8.2 参考实现

参考 `jjyz/server/fightsrv` 的实现：

1. **属性计算器注册**（`jjyz/server/fightsrv/engine/attr_calc.go`）：
   ```go
   type CalcCBFn func(iface.IEntity, *attrcalc.FightAttrCalc)
   
   func RegIncAttrCalcFn(sysId uint32, cb CalcCBFn)
   func RegDecAttrCalcFn(sysId uint32, cb CalcCBFn)
   func GetIncAttrCalcFn(sysId uint32) CalcCBFn
   func GetDecAttrCalcFn(sysId uint32) CalcCBFn
   ```

2. **AttrSys.ResetSysAttr**（`jjyz/server/fightsrv/entitysystem/attr_sys.go:190`）：
   ```go
   func (sys *AttrSys) ResetSysAttr(sysId uint32) {
       if cb := engine.GetIncAttrCalcFn(sysId); nil != cb {
           calc := sys.attrSet.GetIncAttr(sysId, true, true)
           cb(sys.owner, calc)
           sys.bNeedReset = true
       }
       if cb := engine.GetDecAttrCalcFn(sysId); nil != cb {
           calc := sys.attrSet.GetDecAttr(sysId, true, true)
           cb(sys.owner, calc)
           sys.bNeedReset = true
       }
   }
   ```

3. **怪物属性计算器注册**（`jjyz/server/fightsrv/entity/monster.go:1555`）：
   ```go
   func monsterBaseProperty(et iface.IEntity, calc *attrcalc.FightAttrCalc) {
       if monster, ok := et.(*Monster); ok {
           monster.baseProperty(calc)
       }
   }
   
   func init() {
       engine.RegIncAttrCalcFn(attrdef.MonsterBaseProperty, monsterBaseProperty)
   }
   ```

### 8.3 实现步骤

#### 步骤 1：创建属性计算器注册管理器

在 `server/service/dungeonserver/internel/entitysystem/attrcalc/` 目录下创建 `bus.go`：

```go
package attrcalc

import (
    "postapocgame/server/internal/attrcalc"
    "postapocgame/server/internal/attrdef"
    "postapocgame/server/service/dungeonserver/internel/iface"
)

// IncAttrCalcFn 增量属性计算回调
type IncAttrCalcFn func(owner iface.IEntity, calc *attrcalc.FightAttrCalc)

// DecAttrCalcFn 减量属性计算回调
type DecAttrCalcFn func(owner iface.IEntity, calc *attrcalc.FightAttrCalc)

var (
    incCallbacks = make(map[uint32]IncAttrCalcFn)
    decCallbacks = make(map[uint32]DecAttrCalcFn)
)

// RegIncAttrCalcFn 注册增量属性计算回调
func RegIncAttrCalcFn(sysId uint32, fn IncAttrCalcFn) {
    if fn == nil {
        log.Errorf("RegIncAttrCalcFn: fn is nil for sysId=%d", sysId)
        return
    }
    if _, exists := incCallbacks[sysId]; exists {
        log.Errorf("RegIncAttrCalcFn: sysId=%d already registered", sysId)
        return
    }
    incCallbacks[sysId] = fn
}

// RegDecAttrCalcFn 注册减量属性计算回调
func RegDecAttrCalcFn(sysId uint32, fn DecAttrCalcFn) {
    if fn == nil {
        log.Errorf("RegDecAttrCalcFn: fn is nil for sysId=%d", sysId)
        return
    }
    if _, exists := decCallbacks[sysId]; exists {
        log.Errorf("RegDecAttrCalcFn: sysId=%d already registered", sysId)
        return
    }
    decCallbacks[sysId] = fn
}

// GetIncAttrCalcFn 获取增量属性计算回调
func GetIncAttrCalcFn(sysId uint32) IncAttrCalcFn {
    return incCallbacks[sysId]
}

// GetDecAttrCalcFn 获取减量属性计算回调
func GetDecAttrCalcFn(sysId uint32) DecAttrCalcFn {
    return decCallbacks[sysId]
}
```

#### 步骤 2：在 AttrSys 中实现 ResetSysAttr 方法

在 `server/service/dungeonserver/internel/entitysystem/attr_sys.go` 中添加：

```go
import (
    dungeonattrcalc "postapocgame/server/service/dungeonserver/internel/entitysystem/attrcalc"
)

// ResetSysAttr 重置指定系统的属性（通过注册管理器计算）
func (as *AttrSys) ResetSysAttr(sysId uint32) {
    // 1. 获取增量计算回调
    if incFn := dungeonattrcalc.GetIncAttrCalcFn(sysId); incFn != nil {
        calc := as.attrSet.GetIncAttr(sysId, true, true)
        incFn(as.owner, calc)
        as.MarkDirty()
    }
    
    // 2. 获取减量计算回调
    if decFn := dungeonattrcalc.GetDecAttrCalcFn(sysId); decFn != nil {
        calc := as.attrSet.GetDecAttr(sysId, true, true)
        decFn(as.owner, calc)
        as.MarkDirty()
    }
}
```

#### 步骤 3：实现怪物基础属性计算器

在 `server/service/dungeonserver/internel/entity/monster.go` 中实现：

```go
import (
    dungeonattrcalc "postapocgame/server/service/dungeonserver/internel/entitysystem/attrcalc"
    "postapocgame/server/internal/attrdef"
    "postapocgame/server/internal/jsonconf"
)

// monsterBaseProperty 怪物基础属性计算
func monsterBaseProperty(owner iface.IEntity, calc *attrcalc.FightAttrCalc) {
    monster, ok := owner.(*Monster)
    if !ok {
        return
    }
    
    // 从怪物配置表读取基础属性
    monsterConf := jsonconf.GetConfigManager().GetMonsterConfig(monster.GetMonsterId())
    if monsterConf == nil {
        return
    }
    
    // 设置基础属性
    if monsterConf.Attack > 0 {
        calc.AddValue(attrdef.AttrAttack, attrdef.AttrValue(monsterConf.Attack))
    }
    if monsterConf.Defense > 0 {
        calc.AddValue(attrdef.AttrDefense, attrdef.AttrValue(monsterConf.Defense))
    }
    if monsterConf.MaxHP > 0 {
        calc.AddValue(attrdef.AttrMaxHP, attrdef.AttrValue(monsterConf.MaxHP))
    }
    // ... 其他属性
}

func init() {
    // 注册怪物基础属性计算器
    dungeonattrcalc.RegIncAttrCalcFn(attrdef.MonsterBaseProperty, monsterBaseProperty)
}
```

#### 步骤 4：实现 Buff 系统属性计算器

在 `server/service/dungeonserver/internel/entitysystem/buff_sys.go` 中实现：

```go
import (
    dungeonattrcalc "postapocgame/server/service/dungeonserver/internel/entitysystem/attrcalc"
    "postapocgame/server/internal/attrdef"
)

// buffAttrCalc Buff 属性计算
func buffAttrCalc(owner iface.IEntity, calc *attrcalc.FightAttrCalc) {
    buffSys := owner.GetBuffSys()
    if buffSys == nil {
        return
    }
    
    // 遍历所有 Buff，汇总属性加成
    buffSys.EachBuff(func(buff *Buff) {
        if buff.Attrs == nil {
            return
        }
        for attrType, value := range buff.Attrs {
            calc.AddValue(attrdef.AttrType(attrType), attrdef.AttrValue(value))
        }
    })
}

func init() {
    // 注册 Buff 属性计算器
    dungeonattrcalc.RegIncAttrCalcFn(attrdef.SaBuff, buffAttrCalc)
}
```

#### 步骤 5：在实体创建/更新时触发属性计算

在 `server/service/dungeonserver/internel/entity/monster.go` 的 `NewMonster` 中：

```go
func NewMonsterEntity(...) *MonsterEntity {
    // ... 创建逻辑
    
    // 计算并应用怪物属性（通过 ResetProperty 触发完整流程）
    entity.ResetProperty()
    
    // 设置初始HP/MP为最大值
    // ...
    
    return entity
}

// ResetProperty 重置怪物属性（重新计算基础属性并触发属性汇总）
func (m *MonsterEntity) ResetProperty() {
    if m.GetAttrSys() == nil {
        return
    }
    // 1. 重新计算怪物基础属性
    m.GetAttrSys().ResetSysAttr(uint32(protocol.SaAttrSys_MonsterBaseProperty))
    // 2. 触发属性汇总、转换、百分比加成和广播
    m.GetAttrSys().ResetProperty()
}
```

**重要**：必须调用 `ResetProperty()` 而不是只调用 `ResetSysAttr`，因为 `ResetProperty()` 会触发完整的属性计算流程（汇总、转换、百分比加成、广播）。

在 `server/service/dungeonserver/internel/entitysystem/buff_sys.go` 的 Buff 添加/移除时：

```go
func (bs *BuffSys) AddBuff(...) {
    // ... 添加 Buff 逻辑
    
    // 触发 Buff 属性重算
    bs.owner.GetAttrSys().ResetSysAttr(attrdef.SaBuff)
}
```

### 8.4 属性汇总逻辑

**RoleEntity 的属性来源：**

1. **GameServer 属性**：通过 `ApplySyncData` 写入 `attrSet`（系统ID 为 GameServer 的系统ID，如 `SaLevel`、`SaEquip` 等）
2. **Buff 属性**：通过 `ResetSysAttr(attrdef.SaBuff)` 计算，写入 `attrSet`（系统ID 为 `attrdef.SaBuff`）
3. **其他战斗服系统属性**：通过各自的 `ResetSysAttr` 计算，写入 `attrSet`（如 `attrdef.MonsterBaseProperty`）

**属性汇总流程：**

```
GameServer 下发属性 → ApplySyncData → attrSet.GetIncAttr(GameServer系统ID)
Buff 变化 → ResetSysAttr(SaBuff) → attrSet.GetIncAttr(SaBuff)
怪物创建 → ResetSysAttr(MonsterBaseProperty) → attrSet.GetIncAttr(MonsterBaseProperty)
...
ResetProperty → attrSet.ResetProperty(temp) → 汇总所有系统属性 → 应用转换/百分比 → 广播
```

### 8.5 提取公共工具包

**目标**：将 GameServer 和 DungeonServer 的属性计算器注册逻辑提取到公共包，减少重复代码。

**方案**：

1. **在 `server/internal/attrcalc/` 中创建通用注册管理器**：
   - 定义通用的注册接口和回调类型
   - 提供线程安全的注册/获取方法

2. **GameServer 和 DungeonServer 各自实现适配层**：
   - GameServer: 使用 `SysAttrCalculator` 接口（返回 `[]*protocol.AttrSt`）
   - DungeonServer: 使用 `IncAttrCalcFn/DecAttrCalcFn` 回调（直接操作 `FightAttrCalc`）

3. **统一接口设计**：
   ```go
   // server/internal/attrcalc/bus.go
   type AttrCalcBus interface {
       RegisterInc(sysId uint32, fn func(owner interface{}, calc *FightAttrCalc))
       RegisterDec(sysId uint32, fn func(owner interface{}, calc *FightAttrCalc))
       GetInc(sysId uint32) func(owner interface{}, calc *FightAttrCalc)
       GetDec(sysId uint32) func(owner interface{}, calc *FightAttrCalc)
   }
   ```

### 8.6 检查清单

- [x] 创建 `server/service/dungeonserver/internel/entitysystem/attrcalc/bus.go`
- [x] 在 `AttrSys` 中实现 `ResetSysAttr` 方法
- [x] 在 `IAttrSys` 接口中添加 `ResetProperty` 方法定义
- [x] 实现怪物基础属性计算器并注册
- [x] 实现 Buff 系统属性计算器并注册
- [x] 在 `MonsterEntity` 中实现 `ResetProperty()` 方法
- [x] 在实体创建时调用 `ResetProperty()` 触发完整属性计算流程
- [x] **添加 `extraUpdateMask` 和 `bInitFinish` 到 AttrSys**
- [x] **实现 `CheckAndSyncProp` 方法（检查并同步非战斗属性变化）**
- [x] **实现 `RunOne` 方法（每帧调用 `ResetProperty` 和 `CheckAndSyncProp`）**
- [x] **在 `BaseEntity.RunOne` 中调用 `AttrSys.RunOne`**
- [x] **在 `SetAttrValue` 中设置 `extraUpdateMask`（跟踪非战斗属性变化）**
- [x] **实现 `SetInitFinish` 方法（标记初始化完成，允许广播属性）**
- [x] **在实体创建完成后调用 `SetInitFinish`**
- [ ] 提取公共工具包到 `server/internal/attrcalc/`（低优先级）
- [x] 更新文档和注释
- [x] 编译测试

## 9. 后续优化建议

1. **属性计算缓存**
   - 对于不经常变化的属性，可以考虑缓存计算结果

2. **属性计算优化**
   - 对于大量系统的属性计算，可以考虑并行计算

3. **属性同步优化**
   - 实现属性同步的批量处理
   - 实现属性同步的优先级机制

4. **属性调试工具**
   - 添加属性计算的调试日志
   - 添加属性变化的追踪工具

5. **属性配置化**
   - 将属性计算规则配置化
   - 将属性转换规则配置化
   - 将战力计算公式配置化

