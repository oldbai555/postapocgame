// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.9.2

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	adminOperationLogFieldNames          = builder.RawFieldNames(&AdminOperationLog{})
	adminOperationLogRows                = strings.Join(adminOperationLogFieldNames, ",")
	adminOperationLogRowsExpectAutoSet   = strings.Join(stringx.Remove(adminOperationLogFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	adminOperationLogRowsWithPlaceHolder = strings.Join(stringx.Remove(adminOperationLogFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheAdminOperationLogIdPrefix = "cache:adminOperationLog:id:"
)

type (
	adminOperationLogModel interface {
		Insert(ctx context.Context, data *AdminOperationLog) (sql.Result, error)
		FindOne(ctx context.Context, id uint64) (*AdminOperationLog, error)
		Update(ctx context.Context, data *AdminOperationLog) error
		Delete(ctx context.Context, id uint64) error
		FindPage(ctx context.Context, page, pageSize int64) ([]AdminOperationLog, int64, error)
		FindChunk(ctx context.Context, limit int64, lastId uint64) ([]AdminOperationLog, uint64, error)
	}

	defaultAdminOperationLogModel struct {
		sqlc.CachedConn
		table string
	}

	AdminOperationLog struct {
		Id              uint64         `db:"id"`               // 主键 ID
		UserId          uint64         `db:"user_id"`          // 用户 ID
		Username        string         `db:"username"`         // 用户名
		OperationType   string         `db:"operation_type"`   // 操作类型：create/update/delete/query/export等
		OperationObject string         `db:"operation_object"` // 操作对象（模块/表名，如user/role/permission）
		Method          string         `db:"method"`           // 请求方法：GET/POST/PUT/DELETE
		Path            string         `db:"path"`             // 请求路径
		RequestParams   sql.NullString `db:"request_params"`   // 请求参数（JSON格式）
		ResponseCode    int64          `db:"response_code"`    // 响应状态码
		ResponseMsg     string         `db:"response_msg"`     // 响应消息
		IpAddress       string         `db:"ip_address"`       // IP 地址
		UserAgent       string         `db:"user_agent"`       // 用户代理
		Duration        int64          `db:"duration"`         // 请求耗时（毫秒）
		CreatedAt       int64          `db:"created_at"`       // 创建时间(秒级时间戳)
		UpdatedAt       int64          `db:"updated_at"`       // 更新时间(秒级时间戳)
		DeletedAt       int64          `db:"deleted_at"`       // 删除时间(秒级时间戳,0表示未删除)
	}
)

func newAdminOperationLogModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultAdminOperationLogModel {
	return &defaultAdminOperationLogModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`admin_operation_log`",
	}
}

func (m *defaultAdminOperationLogModel) Delete(ctx context.Context, id uint64) error {
	adminOperationLogIdKey := fmt.Sprintf("%s%v", cacheAdminOperationLogIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 检查是否有 deleted_at 字段：通过检查结构体字段名列表
		fieldNames := builder.RawFieldNames(&AdminOperationLog{})
		fieldNamesStr := strings.Join(fieldNames, ",")
		hasDeletedAt := strings.Contains(fieldNamesStr, "deleted_at")

		var query string
		if hasDeletedAt {
			// 软删除：设置 deleted_at 为当前时间戳
			query = fmt.Sprintf("update %s set deleted_at = UNIX_TIMESTAMP(), updated_at = UNIX_TIMESTAMP() where `id` = ? and deleted_at = 0", m.table)
		} else {
			// 物理删除：直接删除记录
			query = fmt.Sprintf("delete from %s where `id` = ?", m.table)
		}
		return conn.ExecCtx(ctx, query, id)
	}, adminOperationLogIdKey)
	return err
}

func (m *defaultAdminOperationLogModel) FindOne(ctx context.Context, id uint64) (*AdminOperationLog, error) {
	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminOperationLogRows, "deleted_at")
	whereClause := "where `id` = ?"
	if hasDeletedAt {
		whereClause += " and deleted_at = 0"
	}
	adminOperationLogIdKey := fmt.Sprintf("%s%v", cacheAdminOperationLogIdPrefix, id)
	var resp AdminOperationLog
	err := m.QueryRowCtx(ctx, &resp, adminOperationLogIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s %s limit 1", adminOperationLogRows, m.table, whereClause)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultAdminOperationLogModel) Insert(ctx context.Context, data *AdminOperationLog) (sql.Result, error) {
	// 自动设置创建时间和更新时间
	if data.CreatedAt == 0 {
		data.CreatedAt = time.Now().Unix()
	}
	if data.UpdatedAt == 0 {
		data.UpdatedAt = time.Now().Unix()
	}
	// 注意：如果表没有 deleted_at 字段，data.DeletedAt 将不存在，不能访问
	// deleted_at 字段如果存在，它已经在 RowsExpectAutoSet 中，不需要特殊处理
	adminOperationLogIdKey := fmt.Sprintf("%s%v", cacheAdminOperationLogIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 手动构建包含 created_at、updated_at 的插入语句
		// 如果表有 deleted_at 字段，它已经在 RowsExpectAutoSet 中，不需要重复添加
		query := fmt.Sprintf("insert into %s (%s, `created_at`, `updated_at`) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, adminOperationLogRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.UserId, data.Username, data.OperationType, data.OperationObject, data.Method, data.Path, data.RequestParams, data.ResponseCode, data.ResponseMsg, data.IpAddress, data.UserAgent, data.Duration, data.DeletedAt, data.CreatedAt, data.UpdatedAt)
	}, adminOperationLogIdKey)
	return ret, err
}

func (m *defaultAdminOperationLogModel) Update(ctx context.Context, data *AdminOperationLog) error {
	adminOperationLogIdKey := fmt.Sprintf("%s%v", cacheAdminOperationLogIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 自动设置更新时间
		data.UpdatedAt = time.Now().Unix()
		// 检查是否有 deleted_at 字段
		hasDeletedAt := strings.Contains(adminOperationLogRowsWithPlaceHolder, "deleted_at")
		// 手动构建包含 updated_at 的更新语句
		whereClause := "where `id` = ?"
		if hasDeletedAt {
			whereClause += " and deleted_at = 0"
		}
		query := fmt.Sprintf("update %s set %s, `updated_at` = %d %s", m.table, adminOperationLogRowsWithPlaceHolder, data.UpdatedAt, whereClause)
		return conn.ExecCtx(ctx, query, data.UserId, data.Username, data.OperationType, data.OperationObject, data.Method, data.Path, data.RequestParams, data.ResponseCode, data.ResponseMsg, data.IpAddress, data.UserAgent, data.Duration, data.DeletedAt, data.Id)
	}, adminOperationLogIdKey)
	return err
}

func (m *defaultAdminOperationLogModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheAdminOperationLogIdPrefix, primary)
}

func (m *defaultAdminOperationLogModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminOperationLogRows, "deleted_at")
	andClause := ""
	if hasDeletedAt {
		andClause = " and deleted_at = 0"
	}
	query := fmt.Sprintf("select %s from %s where `id` = ?%s limit 1", adminOperationLogRows, m.table, andClause)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultAdminOperationLogModel) tableName() string {
	return m.table
}

// 分页查询：根据页码和每页数量查询数据
func (m *defaultAdminOperationLogModel) FindPage(ctx context.Context, page, pageSize int64) ([]AdminOperationLog, int64, error) {
	if page <= 0 {
		page = 1
	}
	if pageSize <= 0 {
		pageSize = 20
	}
	if pageSize > 100 {
		pageSize = 100
	}

	offset := (page - 1) * pageSize

	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminOperationLogRows, "deleted_at")
	whereClause := ""
	if hasDeletedAt {
		whereClause = "where deleted_at = 0"
	}

	// 查询总数
	var total int64
	countQuery := fmt.Sprintf("select count(*) from %s %s", m.table, whereClause)
	err := m.QueryRowNoCacheCtx(ctx, &total, countQuery)
	if err != nil {
		return nil, 0, err
	}

	// 查询分页数据
	var list []AdminOperationLog
	query := fmt.Sprintf("select %s from %s %s order by id desc limit %d offset %d", adminOperationLogRows, m.table, whereClause, pageSize, offset)
	err = m.QueryRowsNoCacheCtx(ctx, &list, query)
	if err != nil {
		return nil, 0, err
	}

	return list, total, nil
}

// 分片查询：基于lastId的分片查询，一次查询limit条，返回数据和下次查询的lastId
// lastId=0表示第一次查询，返回的lastId用于下次查询，当返回的lastId=0或数据为空时表示无更多数据
func (m *defaultAdminOperationLogModel) FindChunk(ctx context.Context, limit int64, lastId uint64) ([]AdminOperationLog, uint64, error) {
	if limit <= 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100
	}

	var list []AdminOperationLog
	var err error

	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminOperationLogRows, "deleted_at")
	whereClause := ""
	if hasDeletedAt {
		whereClause = "where deleted_at = 0"
	}

	if lastId == 0 {
		// 第一次查询
		query := fmt.Sprintf("select %s from %s %s order by id asc limit %d", adminOperationLogRows, m.table, whereClause, limit)
		err = m.QueryRowsNoCacheCtx(ctx, &list, query)
	} else {
		// 基于lastId的分片查询
		andClause := ""
		if hasDeletedAt {
			andClause = "where deleted_at = 0 and id > ?"
		} else {
			andClause = "where id > ?"
		}
		query := fmt.Sprintf("select %s from %s %s order by id asc limit %d", adminOperationLogRows, m.table, andClause, limit)
		err = m.QueryRowsNoCacheCtx(ctx, &list, query, lastId)
	}

	if err != nil {
		return nil, 0, err
	}

	// 返回最后一条记录的ID，用于下次查询；如果数据为空，返回0表示无更多数据
	nextLastId := uint64(0)
	if len(list) > 0 {
		nextLastId = list[len(list)-1].Id
	}

	return list, nextLastId, nil
}
