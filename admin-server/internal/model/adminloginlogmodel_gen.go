// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.9.2

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	adminLoginLogFieldNames          = builder.RawFieldNames(&AdminLoginLog{})
	adminLoginLogRows                = strings.Join(adminLoginLogFieldNames, ",")
	adminLoginLogRowsExpectAutoSet   = strings.Join(stringx.Remove(adminLoginLogFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	adminLoginLogRowsWithPlaceHolder = strings.Join(stringx.Remove(adminLoginLogFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheAdminLoginLogIdPrefix = "cache:adminLoginLog:id:"
)

type (
	adminLoginLogModel interface {
		Insert(ctx context.Context, data *AdminLoginLog) (sql.Result, error)
		FindOne(ctx context.Context, id uint64) (*AdminLoginLog, error)
		Update(ctx context.Context, data *AdminLoginLog) error
		Delete(ctx context.Context, id uint64) error
		FindPage(ctx context.Context, page, pageSize int64) ([]AdminLoginLog, int64, error)
		FindChunk(ctx context.Context, limit int64, lastId uint64) ([]AdminLoginLog, uint64, error)
	}

	defaultAdminLoginLogModel struct {
		sqlc.CachedConn
		table string
	}

	AdminLoginLog struct {
		Id        uint64 `db:"id"`         // 主键 ID
		UserId    uint64 `db:"user_id"`    // 用户 ID
		Username  string `db:"username"`   // 用户名
		IpAddress string `db:"ip_address"` // 登录 IP 地址
		Location  string `db:"location"`   // 登录地点（通过IP解析）
		Browser   string `db:"browser"`    // 浏览器
		Os        string `db:"os"`         // 操作系统
		UserAgent string `db:"user_agent"` // 用户代理
		Status    int64  `db:"status"`     // 登录状态：0失败 1成功
		Message   string `db:"message"`    // 登录消息（失败原因或成功提示）
		LoginAt   int64  `db:"login_at"`   // 登录时间(秒级时间戳)
		LogoutAt  int64  `db:"logout_at"`  // 登出时间(秒级时间戳,0表示未登出)
		CreatedAt int64  `db:"created_at"` // 创建时间(秒级时间戳)
		UpdatedAt int64  `db:"updated_at"` // 更新时间(秒级时间戳)
		DeletedAt int64  `db:"deleted_at"` // 删除时间(秒级时间戳,0表示未删除)
	}
)

func newAdminLoginLogModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultAdminLoginLogModel {
	return &defaultAdminLoginLogModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`admin_login_log`",
	}
}

func (m *defaultAdminLoginLogModel) Delete(ctx context.Context, id uint64) error {
	adminLoginLogIdKey := fmt.Sprintf("%s%v", cacheAdminLoginLogIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 检查是否有 deleted_at 字段：通过检查结构体字段名列表
		fieldNames := builder.RawFieldNames(&AdminLoginLog{})
		fieldNamesStr := strings.Join(fieldNames, ",")
		hasDeletedAt := strings.Contains(fieldNamesStr, "deleted_at")

		var query string
		if hasDeletedAt {
			// 软删除：设置 deleted_at 为当前时间戳
			query = fmt.Sprintf("update %s set deleted_at = UNIX_TIMESTAMP(), updated_at = UNIX_TIMESTAMP() where `id` = ? and deleted_at = 0", m.table)
		} else {
			// 物理删除：直接删除记录
			query = fmt.Sprintf("delete from %s where `id` = ?", m.table)
		}
		return conn.ExecCtx(ctx, query, id)
	}, adminLoginLogIdKey)
	return err
}

func (m *defaultAdminLoginLogModel) FindOne(ctx context.Context, id uint64) (*AdminLoginLog, error) {
	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminLoginLogRows, "deleted_at")
	whereClause := "where `id` = ?"
	if hasDeletedAt {
		whereClause += " and deleted_at = 0"
	}
	adminLoginLogIdKey := fmt.Sprintf("%s%v", cacheAdminLoginLogIdPrefix, id)
	var resp AdminLoginLog
	err := m.QueryRowCtx(ctx, &resp, adminLoginLogIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s %s limit 1", adminLoginLogRows, m.table, whereClause)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultAdminLoginLogModel) Insert(ctx context.Context, data *AdminLoginLog) (sql.Result, error) {
	// 自动设置创建时间和更新时间
	if data.CreatedAt == 0 {
		data.CreatedAt = time.Now().Unix()
	}
	if data.UpdatedAt == 0 {
		data.UpdatedAt = time.Now().Unix()
	}
	// 注意：如果表没有 deleted_at 字段，data.DeletedAt 将不存在，不能访问
	// deleted_at 字段如果存在，它已经在 RowsExpectAutoSet 中，不需要特殊处理
	adminLoginLogIdKey := fmt.Sprintf("%s%v", cacheAdminLoginLogIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 手动构建包含 created_at、updated_at 的插入语句
		// 如果表有 deleted_at 字段，它已经在 RowsExpectAutoSet 中，不需要重复添加
		query := fmt.Sprintf("insert into %s (%s, `created_at`, `updated_at`) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, adminLoginLogRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.UserId, data.Username, data.IpAddress, data.Location, data.Browser, data.Os, data.UserAgent, data.Status, data.Message, data.LoginAt, data.LogoutAt, data.DeletedAt, data.CreatedAt, data.UpdatedAt)
	}, adminLoginLogIdKey)
	return ret, err
}

func (m *defaultAdminLoginLogModel) Update(ctx context.Context, data *AdminLoginLog) error {
	adminLoginLogIdKey := fmt.Sprintf("%s%v", cacheAdminLoginLogIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 自动设置更新时间
		data.UpdatedAt = time.Now().Unix()
		// 检查是否有 deleted_at 字段
		hasDeletedAt := strings.Contains(adminLoginLogRowsWithPlaceHolder, "deleted_at")
		// 手动构建包含 updated_at 的更新语句
		whereClause := "where `id` = ?"
		if hasDeletedAt {
			whereClause += " and deleted_at = 0"
		}
		query := fmt.Sprintf("update %s set %s, `updated_at` = %d %s", m.table, adminLoginLogRowsWithPlaceHolder, data.UpdatedAt, whereClause)
		return conn.ExecCtx(ctx, query, data.UserId, data.Username, data.IpAddress, data.Location, data.Browser, data.Os, data.UserAgent, data.Status, data.Message, data.LoginAt, data.LogoutAt, data.DeletedAt, data.Id)
	}, adminLoginLogIdKey)
	return err
}

func (m *defaultAdminLoginLogModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheAdminLoginLogIdPrefix, primary)
}

func (m *defaultAdminLoginLogModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminLoginLogRows, "deleted_at")
	andClause := ""
	if hasDeletedAt {
		andClause = " and deleted_at = 0"
	}
	query := fmt.Sprintf("select %s from %s where `id` = ?%s limit 1", adminLoginLogRows, m.table, andClause)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultAdminLoginLogModel) tableName() string {
	return m.table
}

// 分页查询：根据页码和每页数量查询数据
func (m *defaultAdminLoginLogModel) FindPage(ctx context.Context, page, pageSize int64) ([]AdminLoginLog, int64, error) {
	if page <= 0 {
		page = 1
	}
	if pageSize <= 0 {
		pageSize = 20
	}
	if pageSize > 100 {
		pageSize = 100
	}

	offset := (page - 1) * pageSize

	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminLoginLogRows, "deleted_at")
	whereClause := ""
	if hasDeletedAt {
		whereClause = "where deleted_at = 0"
	}

	// 查询总数
	var total int64
	countQuery := fmt.Sprintf("select count(*) from %s %s", m.table, whereClause)
	err := m.QueryRowNoCacheCtx(ctx, &total, countQuery)
	if err != nil {
		return nil, 0, err
	}

	// 查询分页数据
	var list []AdminLoginLog
	query := fmt.Sprintf("select %s from %s %s order by id desc limit %d offset %d", adminLoginLogRows, m.table, whereClause, pageSize, offset)
	err = m.QueryRowsNoCacheCtx(ctx, &list, query)
	if err != nil {
		return nil, 0, err
	}

	return list, total, nil
}

// 分片查询：基于lastId的分片查询，一次查询limit条，返回数据和下次查询的lastId
// lastId=0表示第一次查询，返回的lastId用于下次查询，当返回的lastId=0或数据为空时表示无更多数据
func (m *defaultAdminLoginLogModel) FindChunk(ctx context.Context, limit int64, lastId uint64) ([]AdminLoginLog, uint64, error) {
	if limit <= 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100
	}

	var list []AdminLoginLog
	var err error

	// 检查是否有 deleted_at 字段
	hasDeletedAt := strings.Contains(adminLoginLogRows, "deleted_at")
	whereClause := ""
	if hasDeletedAt {
		whereClause = "where deleted_at = 0"
	}

	if lastId == 0 {
		// 第一次查询
		query := fmt.Sprintf("select %s from %s %s order by id asc limit %d", adminLoginLogRows, m.table, whereClause, limit)
		err = m.QueryRowsNoCacheCtx(ctx, &list, query)
	} else {
		// 基于lastId的分片查询
		andClause := ""
		if hasDeletedAt {
			andClause = "where deleted_at = 0 and id > ?"
		} else {
			andClause = "where id > ?"
		}
		query := fmt.Sprintf("select %s from %s %s order by id asc limit %d", adminLoginLogRows, m.table, andClause, limit)
		err = m.QueryRowsNoCacheCtx(ctx, &list, query, lastId)
	}

	if err != nil {
		return nil, 0, err
	}

	// 返回最后一条记录的ID，用于下次查询；如果数据为空，返回0表示无更多数据
	nextLastId := uint64(0)
	if len(list) > 0 {
		nextLastId = list[len(list)-1].Id
	}

	return list, nextLastId, nil
}
