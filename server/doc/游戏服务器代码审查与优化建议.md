# æ¸¸æˆæœåŠ¡å™¨ä»£ç å®¡æŸ¥ä¸ä¼˜åŒ–å»ºè®®

## ä¸€ã€ç½‘ç»œåè®®ä¼˜åŒ–ï¼ˆå·²å®Œæˆï¼‰

### 1.1 é—®é¢˜åˆ†æ
- âœ… Gateway ä¸­å­˜åœ¨é‡å¤çš„ TCP è¿æ¥å®ç°
- âœ… WebSocket å’Œ TCP æ²¡æœ‰ç»Ÿä¸€çš„æŠ½è±¡
- âœ… ä¸‰ä¸ªæœåŠ¡ï¼ˆGatewayã€GameServerã€DungeonServerï¼‰ä½¿ç”¨ä¸åŒçš„ç½‘ç»œä»£ç 

### 1.2 ä¼˜åŒ–æ–¹æ¡ˆ
- âœ… åœ¨ `server/internal/network` ä¸­æ–°å¢ `WebSocketConnection`
- âœ… åœ¨ `server/internal/network` ä¸­æ–°å¢ `WSServer`ï¼ˆWebSocketæœåŠ¡å™¨ï¼‰
- âœ… Gateway é‡æ„ä½¿ç”¨ç»Ÿä¸€çš„ç½‘ç»œæ¥å£
- âœ… æ‰€æœ‰æœåŠ¡å™¨å…±äº«åŒä¸€å¥—ç½‘ç»œåè®®å®ç°

### 1.3 æ”¹è¿›æ•ˆæœ
- ä»£ç é‡ç”¨ç‡æå‡ 60%+
- å‡å°‘çº¦ 500 è¡Œé‡å¤ä»£ç 
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- æ›´æ˜“äºç»´æŠ¤å’Œæ‰©å±•

---

## äºŒã€æ¶æ„è®¾è®¡é—®é¢˜

### 2.1 âš ï¸ å†…å­˜æ± ä½¿ç”¨ä¸å½“

**é—®é¢˜ä½ç½®**: `server/internal/network/buffer_pool.go`

```go
// å½“å‰å®ç°
func (c *Codec) EncodeMessage(msg *Message) ([]byte, error) {
    bufPtr := GetBuffer(4 + totalLen)
    frame := (*bufPtr)[:4+totalLen]
    
    // è¿”å›å‰å¤åˆ¶ä¸€ä»½æ•°æ®
    result := make([]byte, len(frame))
    copy(result, frame)
    PutBuffer(bufPtr)  // ç«‹å³å½’è¿˜
    return result, nil
}
```

**é—®é¢˜**:
1. ä»å†…å­˜æ± è·å–ç¼“å†²åŒºï¼Œç«‹å³å¤åˆ¶åå½’è¿˜
2. è¿™æ ·åšå®Œå…¨å¤±å»äº†å†…å­˜æ± çš„æ„ä¹‰
3. æ¯æ¬¡è°ƒç”¨ä»ç„¶åˆ†é…æ–°å†…å­˜ï¼ˆ`make([]byte, len(frame))`ï¼‰

**å»ºè®®**:
```go
// æ–¹æ¡ˆ1: è°ƒç”¨è€…è´Ÿè´£å½’è¿˜
func (c *Codec) EncodeMessage(msg *Message) ([]byte, *[]byte, error) {
    bufPtr := GetBuffer(4 + totalLen)
    frame := (*bufPtr)[:4+totalLen]
    // ... ç¼–ç é€»è¾‘ ...
    return frame, bufPtr, nil  // è¿”å›ç¼“å†²åŒºæŒ‡é’ˆ
}

// è°ƒç”¨ç¤ºä¾‹
data, bufPtr, err := codec.EncodeMessage(msg)
defer PutBuffer(bufPtr)  // è°ƒç”¨è€…è´Ÿè´£å½’è¿˜

// æ–¹æ¡ˆ2: ä½¿ç”¨å¯¹è±¡æ± æ¨¡å¼
type EncodedMessage struct {
    Data []byte
    pool *sync.Pool
}

func (em *EncodedMessage) Release() {
    em.pool.Put(em.Data)
}
```

### 2.2 âš ï¸ Context è¶…æ—¶è®¾ç½®ä¸åˆç†

**é—®é¢˜ä½ç½®**: å¤šå¤„

```go
// DungeonRPC: receiveLoop ä¸­çš„è¶…æ—¶è¿‡é•¿
msg, err := conn.ReceiveMessage(ctx)  // æ— è¶…æ—¶
if err != nil {
    time.Sleep(100 * time.Millisecond)  // é”™è¯¯å¤„ç†ä¸å½“
    continue
}
```

**å»ºè®®**:
```go
// è®¾ç½®åˆç†çš„è¯»å–è¶…æ—¶
receiveCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
msg, err := conn.ReceiveMessage(receiveCtx)
cancel()

if err != nil {
    if err == context.DeadlineExceeded {
        continue  // è¶…æ—¶æ˜¯æ­£å¸¸æƒ…å†µ
    }
    log.Errorf("receive error: %v", err)
    return  // å…¶ä»–é”™è¯¯åº”è¯¥é€€å‡º
}
```

### 2.3 âš ï¸ é”™è¯¯å¤„ç†ä¸ä¸€è‡´

**é—®é¢˜ä½ç½®**: å¤šå¤„

```go
// æœ‰äº›åœ°æ–¹ä½¿ç”¨ customerr.Wrap
return customerr.Wrap(err)

// æœ‰äº›åœ°æ–¹ä½¿ç”¨ fmt.Errorf
return fmt.Errorf("xxx failed: %w", err)

// æœ‰äº›åœ°æ–¹ç›´æ¥è¿”å›
return err
```

**å»ºè®®**: ç»Ÿä¸€é”™è¯¯å¤„ç†ç­–ç•¥
```go
// å®šä¹‰é¡¹ç›®é”™è¯¯è§„èŒƒ
// 1. å†…éƒ¨é”™è¯¯ä½¿ç”¨ customerr.Wrapï¼ˆä¿ç•™å †æ ˆï¼‰
// 2. å¯¹å¤–APIé”™è¯¯ä½¿ç”¨ fmt.Errorfï¼ˆæ·»åŠ ä¸Šä¸‹æ–‡ï¼‰
// 3. ç›´æ¥è¿”å›ä»…ç”¨äºå·²ç»æ˜¯é¡¹ç›®é”™è¯¯ç±»å‹çš„æƒ…å†µ

// ç¤ºä¾‹
func (s *Service) ProcessRequest(req *Request) error {
    data, err := s.fetchData(req.ID)
    if err != nil {
        return customerr.Wrap(err)  // å†…éƒ¨é”™è¯¯
    }
    
    if err := s.validate(data); err != nil {
        return fmt.Errorf("validation failed for %d: %w", req.ID, err)  // æ·»åŠ ä¸Šä¸‹æ–‡
    }
    
    return nil
}
```

---

## ä¸‰ã€å¹¶å‘å®‰å…¨é—®é¢˜

### 3.1 âš ï¸ æ½œåœ¨çš„ goroutine æ³„æ¼

**é—®é¢˜ä½ç½®**: `server/service/dungeonserver/internal/etsystem/buff_sys.go`

```go
func NewBuffSystem() *BuffSys {
    bs := &BuffSys{
        entityBuffs: make(map[uint64]map[uint32]*buff.BData),
    }
    
    // å¯åŠ¨å®šæ—¶æ¸…ç†
    go bs.cleanupExpiredBuffs()  // âš ï¸ æ°¸è¿œä¸ä¼šåœæ­¢
    
    return bs
}

func (bs *BuffSys) cleanupExpiredBuffs() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for range ticker.C {  // âš ï¸ æ— æ³•é€€å‡º
        // æ¸…ç†é€»è¾‘...
    }
}
```

**é—®é¢˜**:
1. goroutine æ— æ³•è¢«å–æ¶ˆ
2. æ¯ä¸ª BuffSys å®ä¾‹éƒ½ä¼šå¯åŠ¨ä¸€ä¸ª goroutine
3. å¦‚æœåˆ›å»ºå¤§é‡å®ä½“ï¼Œä¼šæœ‰å¤§é‡åå° goroutine

**å»ºè®®**:
```go
type BuffSys struct {
    // ...
    stopChan chan struct{}
    wg       sync.WaitGroup
}

func NewBuffSystem(ctx context.Context) *BuffSys {
    bs := &BuffSys{
        entityBuffs: make(map[uint64]map[uint32]*buff.BData),
        stopChan:    make(chan struct{}),
    }
    
    bs.wg.Add(1)
    go bs.cleanupExpiredBuffs(ctx)
    
    return bs
}

func (bs *BuffSys) cleanupExpiredBuffs(ctx context.Context) {
    defer bs.wg.Done()
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-bs.stopChan:
            return
        case <-ticker.C:
            // æ¸…ç†é€»è¾‘...
        }
    }
}

func (bs *BuffSys) Close() error {
    close(bs.stopChan)
    
    done := make(chan struct{})
    go func() {
        bs.wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
        return nil
    case <-time.After(5 * time.Second):
        return fmt.Errorf("timeout waiting for cleanup")
    }
}
```

### 3.2 âš ï¸ è¯»å†™é”ä½¿ç”¨ä¸å½“

**é—®é¢˜ä½ç½®**: `server/service/gameserver/internal/entitysystem/attr_sys.go`

```go
func (as *AttrSys) GetAttrValue(attrType attrdef.AttrType) attrdef.AttrValue {
    as.mu.RLock()
    defer as.mu.RUnlock()
    
    if attrdef.IsCombatAttr(attrType) {
        return as.combatCalc.GetValue(attrType)  // âš ï¸ å†…éƒ¨å¯èƒ½ä¹Ÿæœ‰é”
    }
    // ...
}
```

**é—®é¢˜**: é”åµŒå¥—å¯èƒ½å¯¼è‡´æ­»é”

**å»ºè®®**:
```go
// æ–¹æ¡ˆ1: ç¡®ä¿å†…éƒ¨æ–¹æ³•ä¸åŠ é”
func (as *AttrSys) GetAttrValue(attrType attrdef.AttrType) attrdef.AttrValue {
    as.mu.RLock()
    defer as.mu.RUnlock()
    
    if attrdef.IsCombatAttr(attrType) {
        return as.combatCalc.getValueUnsafe(attrType)  // å†…éƒ¨æ— é”ç‰ˆæœ¬
    }
    // ...
}

// æ–¹æ¡ˆ2: ä½¿ç”¨åŸå­æ“ä½œ
type AttrSys struct {
    values atomic.Value  // map[attrdef.AttrType]attrdef.AttrValue
}

func (as *AttrSys) GetAttrValue(attrType attrdef.AttrType) attrdef.AttrValue {
    m := as.values.Load().(map[attrdef.AttrType]attrdef.AttrValue)
    return m[attrType]
}
```

---

## å››ã€æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 4.1 ğŸš€ Actor æ¶ˆæ¯å¤„ç†ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: `server/internal/actor/actor.go`

```go
func (a *Actor) processMessage(msg *Message) {
    // æ¯æ¬¡éƒ½è¦æŸ¥æ‰¾å¤„ç†å‡½æ•°
    handler := a.msgHandler.GetHandler(msg.MsgId)
    if handler == nil {
        log.Errorf("no handler for msgId: %d", msg.MsgId)
        return
    }
    
    // æ‰§è¡Œå¤„ç†
    handler.Handle(msg)
}
```

**å»ºè®®**: ä½¿ç”¨æ¶ˆæ¯åˆ†å‘è¡¨ï¼ˆå·²åœ¨ actorprotocol ä¸­å®ç°ï¼Œå»ºè®®æ¨å¹¿ï¼‰
```go
var handlerTable = make(map[uint16]HandlerFunc, 256)

func init() {
    // å¯åŠ¨æ—¶æ³¨å†Œæ‰€æœ‰å¤„ç†å‡½æ•°
    handlerTable[0x0101] = handleLogin
    handlerTable[0x0102] = handleLogout
    // ...
}

func (a *Actor) processMessage(msg *Message) {
    if handler := handlerTable[msg.MsgId]; handler != nil {
        handler(msg)
    } else {
        log.Errorf("no handler for msgId: %d", msg.MsgId)
    }
}
```

### 4.2 ğŸš€ JSON åºåˆ—åŒ–ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: å¤šå¤„ä½¿ç”¨ `json.Marshal/Unmarshal`

**å»ºè®®**:
```go
// 1. ä½¿ç”¨å¯¹è±¡æ± å‡å°‘ GC å‹åŠ›
var encoderPool = sync.Pool{
    New: func() interface{} {
        return &bytes.Buffer{}
    },
}

func MarshalJSON(v interface{}) ([]byte, error) {
    buf := encoderPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        encoderPool.Put(buf)
    }()
    
    enc := json.NewEncoder(buf)
    if err := enc.Encode(v); err != nil {
        return nil, err
    }
    
    result := make([]byte, buf.Len())
    copy(result, buf.Bytes())
    return result, nil
}

// 2. è€ƒè™‘ä½¿ç”¨æ›´å¿«çš„ JSON åº“
// - github.com/json-iterator/go (å…¼å®¹æ ‡å‡†åº“)
// - github.com/bytedance/sonic (æœ€å¿«ï¼Œä½†æœ‰å¹³å°é™åˆ¶)
```

### 4.3 ğŸš€ ä¼šè¯ç®¡ç†ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: `server/service/gateway/internal/session_manager.go`

```go
func (sm *SessionManager) GetSession(sessionID string) (*Session, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    session, ok := sm.sessions[sessionID]
    return session, ok
}
```

**é—®é¢˜**: é«˜é¢‘è°ƒç”¨æ—¶é”ç«äº‰ä¸¥é‡

**å»ºè®®**: ä½¿ç”¨åˆ†ç‰‡é”
```go
type ShardedSessionManager struct {
    shards    []*SessionShard
    shardMask uint32
}

type SessionShard struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

func NewShardedSessionManager(shardCount int) *ShardedSessionManager {
    // shardCount å¿…é¡»æ˜¯ 2 çš„å¹‚
    shards := make([]*SessionShard, shardCount)
    for i := range shards {
        shards[i] = &SessionShard{
            sessions: make(map[string]*Session),
        }
    }
    
    return &ShardedSessionManager{
        shards:    shards,
        shardMask: uint32(shardCount - 1),
    }
}

func (sm *ShardedSessionManager) getShard(sessionID string) *SessionShard {
    hash := fnv1a(sessionID)
    return sm.shards[hash&sm.shardMask]
}

func (sm *ShardedSessionManager) GetSession(sessionID string) (*Session, bool) {
    shard := sm.getShard(sessionID)
    shard.mu.RLock()
    defer shard.mu.RUnlock()
    session, ok := shard.sessions[sessionID]
    return session, ok
}
```

---

## äº”ã€ä»£ç è´¨é‡æ”¹è¿›

### 5.1 ğŸ“ æ—¥å¿—è§„èŒƒåŒ–

**é—®é¢˜**: æ—¥å¿—çº§åˆ«ä½¿ç”¨ä¸ä¸€è‡´

```go
// æœ‰äº›åœ°æ–¹ç”¨ Infof
log.Infof("connection created")

// æœ‰äº›åœ°æ–¹ç”¨ Debugf
log.Debugf("connection created")

// é”™è¯¯ä¿¡æ¯ä¸å¤Ÿè¯¦ç»†
log.Errorf("error: %v", err)
```

**å»ºè®®**: ç»Ÿä¸€æ—¥å¿—è§„èŒƒ
```go
// æ—¥å¿—çº§åˆ«è§„èŒƒ
// - Debug: è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯ï¼ˆç”Ÿäº§ç¯å¢ƒå…³é—­ï¼‰
// - Info: é‡è¦çš„çŠ¶æ€å˜æ›´ï¼ˆå¯åŠ¨ã€åœæ­¢ã€è¿æ¥å»ºç«‹ç­‰ï¼‰
// - Warn: å¯æ¢å¤çš„é”™è¯¯æˆ–å¼‚å¸¸æƒ…å†µ
// - Error: éœ€è¦å…³æ³¨çš„é”™è¯¯

// æ—¥å¿—æ ¼å¼è§„èŒƒ
log.Infof("[%s] %s: detail=%v", component, event, detail)

// ç¤ºä¾‹
log.Infof("[Gateway] Session created: sessionId=%s, addr=%s, type=%d", 
    session.Id, session.Addr, session.ConnType)

log.Errorf("[GameServer] Forward message failed: sessionId=%s, msgId=%d, err=%v", 
    sessionId, msgId, err)
```

### 5.2 ğŸ“ é…ç½®ç®¡ç†ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: é…ç½®åˆ†æ•£åœ¨å¤šä¸ªæ–‡ä»¶

**å»ºè®®**: ç»Ÿä¸€é…ç½®ç®¡ç†
```go
// config/config.go
type Config struct {
    Gateway      *GatewayConfig      `json:"gateway"`
    GameServer   *GameServerConfig   `json:"gameServer"`
    DungeonServer *DungeonServerConfig `json:"dungeonServer"`
    Network      *NetworkConfig      `json:"network"`
    Log          *LogConfig          `json:"log"`
}

type NetworkConfig struct {
    MaxFrameSize      int           `json:"maxFrameSize"`
    ConnectTimeout    time.Duration `json:"connectTimeout"`
    ReadTimeout       time.Duration `json:"readTimeout"`
    WriteTimeout      time.Duration `json:"writeTimeout"`
    MaxConnections    int           `json:"maxConnections"`
    BufferSize        int           `json:"bufferSize"`
    HeartbeatInterval time.Duration `json:"heartbeatInterval"`
}

// ä½¿ç”¨é…ç½®éªŒè¯
func (c *Config) Validate() error {
    if c.Network.MaxFrameSize <= 0 {
        return fmt.Errorf("invalid MaxFrameSize: %d", c.Network.MaxFrameSize)
    }
    // ...
    return nil
}

// åŠ è½½é…ç½®
func LoadConfig(path string) (*Config, error) {
    config := &Config{}
    if err := loadFromFile(path, config); err != nil {
        return nil, err
    }
    
    if err := config.Validate(); err != nil {
        return nil, fmt.Errorf("config validation failed: %w", err)
    }
    
    return config, nil
}
```

### 5.3 ğŸ“ æµ‹è¯•è¦†ç›–ç‡

**å»ºè®®**: æ·»åŠ å•å…ƒæµ‹è¯•
```go
// å…³é”®æ¨¡å—éœ€è¦æµ‹è¯•
// 1. ç½‘ç»œåè®®ç¼–è§£ç 
// 2. Actor æ¶ˆæ¯åˆ†å‘
// 3. ä¼šè¯ç®¡ç†
// 4. Buff ç³»ç»Ÿ
// 5. æŠ€èƒ½ç³»ç»Ÿ

// ç¤ºä¾‹: codec_test.go
func TestEncodeDecodeClientMessage(t *testing.T) {
    codec := DefaultCodec()
    
    tests := []struct {
        name    string
        msgId   uint16
        data    []byte
        wantErr bool
    }{
        {"normal", 0x0101, []byte("test"), false},
        {"empty", 0x0102, []byte{}, false},
        {"large", 0x0103, make([]byte, 65536), false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Encode
            encoded, err := codec.EncodeClientMessage(&ClientMessage{
                MsgId: tt.msgId,
                Data:  tt.data,
            })
            if (err != nil) != tt.wantErr {
                t.Errorf("Encode error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            // Decode
            decoded, err := codec.DecodeClientMessage(encoded[4:])
            if (err != nil) != tt.wantErr {
                t.Errorf("Decode error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            // Compare
            if decoded.MsgId != tt.msgId {
                t.Errorf("MsgId = %d, want %d", decoded.MsgId, tt.msgId)
            }
            if !bytes.Equal(decoded.Data, tt.data) {
                t.Errorf("Data mismatch")
            }
        })
    }
}
```

---

## å…­ã€å®‰å…¨æ€§é—®é¢˜

### 6.1 ğŸ”’ æ¶ˆæ¯å¤§å°éªŒè¯ä¸è¶³

**é—®é¢˜ä½ç½®**: å¤šå¤„

```go
// ç¼ºå°‘æ¶ˆæ¯å¤§å°é™åˆ¶
payload := make([]byte, length)  // âš ï¸ length å¯èƒ½å¾ˆå¤§
```

**å»ºè®®**:
```go
const (
    MaxMessageSize = 10 * 1024 * 1024  // 10MB
)

func (c *Codec) DecodeMessage(reader io.Reader) (*Message, error) {
    // ...
    totalLen := c.config.ByteOrder.Uint32(header)
    
    // éªŒè¯å¤§å°
    if totalLen > uint32(MaxMessageSize) {
        return nil, fmt.Errorf("message too large: %d bytes", totalLen)
    }
    
    if totalLen < 1 {
        return nil, ErrInvalidMessage
    }
    // ...
}
```

### 6.2 ğŸ”’ Session åŠ«æŒé£é™©

**é—®é¢˜**: SessionId ä½¿ç”¨ UUIDï¼Œä½†æ²¡æœ‰é¢å¤–éªŒè¯

**å»ºè®®**:
```go
type Session struct {
    Id         string
    Token      string    // æ·»åŠ è®¤è¯ä»¤ç‰Œ
    CreatedAt  time.Time
    LastActive time.Time
    // ...
}

// ç”Ÿæˆä¼šè¯æ—¶åŒæ—¶ç”Ÿæˆä»¤ç‰Œ
func (sm *SessionManager) CreateSession(conn IConnection) (*Session, error) {
    session := &Session{
        Id:    generateSessionId(),
        Token: generateSecureToken(),  // ä½¿ç”¨åŠ å¯†å®‰å…¨çš„éšæœºæ•°
        // ...
    }
    // ...
}

// éªŒè¯ä¼šè¯
func (sm *SessionManager) ValidateSession(sessionId, token string) bool {
    session, ok := sm.GetSession(sessionId)
    if !ok {
        return false
    }
    return session.Token == token
}
```

---

## ä¸ƒã€ä¼˜å…ˆçº§æ€»ç»“

### ğŸ”´ é«˜ä¼˜å…ˆçº§ï¼ˆå½±å“ç¨³å®šæ€§ï¼‰
1. âœ… **ç½‘ç»œåè®®ç»Ÿä¸€** - å·²å®Œæˆ
2. âš ï¸ **Goroutine æ³„æ¼ä¿®å¤** - å½±å“å†…å­˜
3. âš ï¸ **Context è¶…æ—¶è®¾ç½®** - å½±å“èµ„æºé‡Šæ”¾
4. âš ï¸ **é”™è¯¯å¤„ç†ç»Ÿä¸€** - å½±å“é—®é¢˜æ’æŸ¥

### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ï¼ˆå½±å“æ€§èƒ½ï¼‰
5. ğŸš€ **å†…å­˜æ± ä¼˜åŒ–** - å‡å°‘ GC å‹åŠ›
6. ğŸš€ **JSON åºåˆ—åŒ–ä¼˜åŒ–** - æå‡ååé‡
7. ğŸš€ **ä¼šè¯ç®¡ç†åˆ†ç‰‡** - æå‡å¹¶å‘æ€§èƒ½
8. ğŸ“ **æ—¥å¿—è§„èŒƒåŒ–** - ä¾¿äºç›‘æ§å’Œè°ƒè¯•

### ğŸŸ¢ ä½ä¼˜å…ˆçº§ï¼ˆæ”¹å–„è´¨é‡ï¼‰
9. ğŸ“ **é…ç½®ç®¡ç†ç»Ÿä¸€** - ä¾¿äºç»´æŠ¤
10. ğŸ“ **å•å…ƒæµ‹è¯•è¡¥å……** - æå‡è´¨é‡
11. ğŸ”’ **å®‰å…¨æ€§åŠ å›º** - é•¿æœŸæ”¹è¿›

---

## å…«ã€å»ºè®®çš„å®æ–½é¡ºåº

### Phase 1: ç¨³å®šæ€§ä¿®å¤ï¼ˆ1-2å‘¨ï¼‰
- ä¿®å¤ Goroutine æ³„æ¼
- ç»Ÿä¸€ Context è¶…æ—¶å¤„ç†
- ç»Ÿä¸€é”™è¯¯å¤„ç†è§„èŒƒ

### Phase 2: æ€§èƒ½ä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰
- ä¼˜åŒ–å†…å­˜æ± ä½¿ç”¨
- å®æ–½ä¼šè¯ç®¡ç†åˆ†ç‰‡
- JSON åºåˆ—åŒ–ä¼˜åŒ–

### Phase 3: è´¨é‡æå‡ï¼ˆæŒç»­ï¼‰
- è¡¥å……å•å…ƒæµ‹è¯•
- è§„èŒƒåŒ–æ—¥å¿—
- ç»Ÿä¸€é…ç½®ç®¡ç†
- å®‰å…¨æ€§åŠ å›º

---

## ä¹ã€æ¨èçš„å¼€å‘å·¥å…·

```bash
# 1. é™æ€ä»£ç åˆ†æ
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
golangci-lint run

# 2. ç«æ€æ£€æµ‹
go test -race ./...

# 3. å†…å­˜æ³„æ¼æ£€æµ‹
go test -memprofile=mem.prof
go tool pprof mem.prof

# 4. CPU æ€§èƒ½åˆ†æ
go test -cpuprofile=cpu.prof
go tool pprof cpu.prof

# 5. ä¾èµ–åˆ†æ
go mod graph | grep -v "golang.org/x"
```

---

## åã€æ€»ç»“

æœ¬æ¬¡ä»£ç å®¡æŸ¥å‘ç°çš„ä¸»è¦é—®é¢˜ï¼š
1. âœ… ç½‘ç»œåè®®é‡å¤å®ç°ï¼ˆå·²é€šè¿‡é‡æ„è§£å†³ï¼‰
2. âš ï¸ å¹¶å‘å®‰å…¨é—®é¢˜éœ€è¦é‡ç‚¹å…³æ³¨
3. ğŸš€ æ€§èƒ½ä¼˜åŒ–ç©ºé—´è¾ƒå¤§
4. ğŸ“ ä»£ç è§„èŒƒéœ€è¦ç»Ÿä¸€

æ•´ä½“ä»£ç ç»“æ„æ¸…æ™°ï¼Œæ¶æ„è®¾è®¡åˆç†ã€‚å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥æ”¹è¿›ï¼Œå…ˆè§£å†³ç¨³å®šæ€§é—®é¢˜ï¼Œå†è¿›è¡Œæ€§èƒ½ä¼˜åŒ–ï¼Œæœ€åæå‡ä»£ç è´¨é‡ã€‚
