# 事件系统迁移指南

## 一、新旧对比

### 旧系统（保持兼容）
```go
// 订阅事件
event.Subscribe(event.EventRoleLogin, func(e *event.Event) error {
    // 处理逻辑
    return nil
})

// 发布事件
event.Publish(event.EventRoleLogin, player)
```

### 新系统（推荐使用）
```go
// 1. 定义系统
type MySystem struct {
    playerID string
}

func (s *MySystem) Name() string { return "MySystem" }

func (s *MySystem) Init(mgr *event.SystemMgr) {
    // 订阅本地事件（只影响此 actor）
    mgr.Subscribe(event.EventRoleLogin, 10, func(ctx context.Context, e *event.Event) error {
        // 处理逻辑
        return nil
    })
    
    // 订阅全局事件（所有 actor 都会收到）
    mgr.Subscribe(event.EventServerShutdown, 100, func(ctx context.Context, e *event.Event) error {
        // 处理逻辑
        return nil
    })
}

func (s *MySystem) OnClose() {
    // 清理逻辑
}

// 2. 注册系统工厂（在 init() 中）
func init() {
    event.RegisterSystemFactory(func() event.ISystem {
        return &MySystem{}
    })
}

// 3. 创建 actor（在玩家登录时）
mgr := event.NewSystemMgr(playerID, 256)

// 4. 发布本地事件
mgr.PublishLocal(event.NewEvent(event.EventRoleLogin, playerID, roleInfo))

// 5. 发布全局事件
event.GlobalPublish(event.NewEvent(event.EventServerShutdown, "server"))

// 6. 关闭 actor（在玩家登出时）
mgr.Close()
```

---

## 二、核心概念

### 1. 事件总线（Bus）
- **LocalBus**: 每个 actor 独立的事件总线，处理本地事件
- **GlobalBus**: 全局广播机制，通过 ActorRegistry 分发到所有 actor

### 2. Actor（SystemMgr）
- 代表一个玩家或独立的处理单元
- 拥有自己的邮箱（Mailbox）和本地事件总线
- 保证事件处理的顺序性（单线程处理）

### 3. System（系统）
- 通过 SystemFactory 注册
- 每个 actor 创建时会实例化所有注册的系统
- 系统在 Init() 中订阅事件

### 4. 优先级
- 数值越大优先级越高
- 同一事件的多个处理器按优先级顺序执行

---

## 三、PlayerRole 改造示例

### 原有代码
```go
type PlayerRole struct {
    SessionId string
    RoleInfo  *protocol.RoleInfo
    eventBus  *event.Bus
    sysMgr    *entitysystem.SysMgr
}

func NewPlayerRole(sessionId string, roleInfo *protocol.RoleInfo) *PlayerRole {
    pr := &PlayerRole{
        SessionId: sessionId,
        RoleInfo:  roleInfo,
        eventBus:  event.NewEventBus(), // ❌ 旧方式
        sysMgr:    entitysystem.NewSysMgr(pr),
    }
    return pr
}

func (pr *PlayerRole) Publish(typ event.Type, args ...interface{}) error {
    return pr.eventBus.Publish(&event.Event{
        Type: typ,
        Data: args,
    })
}
```

### 改造后代码
```go
type PlayerRole struct {
    SessionId string
    RoleInfo  *protocol.RoleInfo
    
    // ✅ 使用新的 SystemMgr（包含 eventBus）
    systemMgr *event.SystemMgr
    
    // 保留旧的 sysMgr（游戏逻辑系统）
    sysMgr *entitysystem.SysMgr
}

func NewPlayerRole(sessionId string, roleInfo *protocol.RoleInfo) *PlayerRole {
    pr := &PlayerRole{
        SessionId: sessionId,
        RoleInfo:  roleInfo,
        
        // ✅ 创建事件系统（actor）
        systemMgr: event.NewSystemMgr(sessionId, 256),
    }
    
    // 创建游戏逻辑系统
    pr.sysMgr = entitysystem.NewSysMgr(pr)
    
    return pr
}

// ✅ 发布本地事件
func (pr *PlayerRole) PublishLocal(typ event.Type, args ...interface{}) error {
    evt := event.NewEvent(typ, pr.SessionId, args...)
    return pr.systemMgr.PublishLocal(evt)
}

// ✅ 订阅事件
func (pr *PlayerRole) Subscribe(eventType event.Type, priority int, handler event.Handler) {
    pr.systemMgr.Subscribe(eventType, priority, handler)
}

// ✅ 关闭时清理
func (pr *PlayerRole) Close() error {
    pr.systemMgr.Close()
    // ... 其他清理逻辑
    return nil
}
```

---

## 四、系统改造示例

### 原有的 LevelSys
```go
type LevelSys struct {
    *BaseSystem
    level uint32
    exp   uint64
}

func NewLevelSys(role iface.IPlayerRole) *LevelSys {
    sys := &LevelSys{
        BaseSystem: NewBaseSystem(custom_id.SysLevel, role),
        level:      role.GetPlayerRoleInfo().Level,
        exp:        0,
    }
    return sys
}

func (s *LevelSys) AddExp(exp uint64) {
    oldLevel := s.level
    s.exp += exp

    for s.exp >= 1000 {
        s.exp -= 1000
        s.level++
    }

    if s.level > oldLevel {
        // ❌ 旧方式
        s.GetRole().Publish(event.EventRoleUpLv, oldLevel, s.level)
    }

    s.SendData()
}
```

### 改造为事件驱动
```go
// 1. 创建独立的事件系统
type LevelEventSystem struct {
    mgr *event.SystemMgr
}

func (s *LevelEventSystem) Name() string { return "LevelEventSystem" }

func (s *LevelEventSystem) Init(mgr *event.SystemMgr) {
    s.mgr = mgr
    
    // 订阅经验增加事件
    mgr.Subscribe(event.EventAddExp, 10, s.onAddExp)
    
    // 订阅升级事件
    mgr.Subscribe(event.EventRoleUpLv, 5, s.onLevelUp)
}

func (s *LevelEventSystem) onAddExp(ctx context.Context, e *event.Event) error {
    exp := e.GetDataAt(0).(uint64)
    
    // 获取 LevelSys
    levelSys := s.getLevelSys()
    if levelSys == nil {
        return nil
    }
    
    levelSys.AddExp(exp)
    return nil
}

func (s *LevelEventSystem) onLevelUp(ctx context.Context, e *event.Event) error {
    oldLevel := e.GetDataAt(0).(uint32)
    newLevel := e.GetDataAt(1).(uint32)
    
    log.Infof("[LevelEventSystem] Player level up: %d -> %d", oldLevel, newLevel)
    
    // 可以触发其他事件，如奖励发放
    return nil
}

func (s *LevelEventSystem) OnClose() {
    // 清理逻辑
}

func (s *LevelEventSystem) getLevelSys() *LevelSys {
    // 从 PlayerRole 获取 LevelSys
    // 需要通过某种方式关联 PlayerRole
    return nil
}

// 2. 注册工厂
func init() {
    event.RegisterSystemFactory(func() event.ISystem {
        return &LevelEventSystem{}
    })
}

// 3. 修改 LevelSys.AddExp
func (s *LevelSys) AddExp(exp uint64) {
    oldLevel := s.level
    s.exp += exp

    for s.exp >= 1000 {
        s.exp -= 1000
        s.level++
    }

    if s.level > oldLevel {
        // ✅ 新方式：发布本地事件
        role := s.GetRole()
        evt := event.NewEvent(event.EventRoleUpLv, role.GetSessionId(), oldLevel, s.level)
        role.PublishLocal(evt)
    }

    s.SendData()
}
```

---

## 五、全局事件示例

### 服务器公告
```go
// 发送全局公告
func BroadcastServerAnnouncement(message string) {
    evt := event.NewEvent(event.EventServerAnnouncement, "server", message)
    event.GlobalPublish(evt)
}

// 所有 actor 的系统都会收到
type ChatSystem struct{}

func (s *ChatSystem) Init(mgr *event.SystemMgr) {
    mgr.Subscribe(event.EventServerAnnouncement, 100, func(ctx context.Context, e *event.Event) error {
        message := e.GetDataAt(0).(string)
        
        // 发送给客户端
        // ...
        
        return nil
    })
}
```

### 世界 BOSS 刷新
```go
// 发布世界 BOSS 事件
func SpawnWorldBoss(bossID uint32, sceneID uint32) {
    evt := event.NewEvent(event.EventWorldBossSpawn, "world", bossID, sceneID)
    event.GlobalPublish(evt)
}

// 所有在线玩家都会收到通知
type BossNotificationSystem struct{}

func (s *BossNotificationSystem) Init(mgr *event.SystemMgr) {
    mgr.Subscribe(event.EventWorldBossSpawn, 80, func(ctx context.Context, e *event.Event) error {
        bossID := e.GetDataAt(0).(uint32)
        sceneID := e.GetDataAt(1).(uint32)
        
        // 通知客户端
        // ...
        
        return nil
    })
}
```

---

## 六、优势总结

### 1. 性能优化
- ✅ 优先级在订阅时排序，发布时不需要排序
- ✅ 事件处理器使用 context 支持超时和取消
- ✅ 非阻塞广播，避免慢消费者卡住系统
- ✅ 邮箱缓冲避免频繁阻塞

### 2. 并发安全
- ✅ 每个 actor 单线程处理事件，无需加锁
- ✅ Registry 机制避免闭包共享问题
- ✅ 克隆而非共享事件总线

### 3. 可维护性
- ✅ 系统职责清晰，易于测试
- ✅ 事件驱动解耦模块
- ✅ 支持动态添加/移除系统

### 4. 可扩展性
- ✅ 支持本地和全局事件
- ✅ 支持事件追踪和监控
- ✅ 易于添加新的事件类型和处理器

---

## 七、迁移步骤

### Step 1: 保持兼容（1-2天）
1. 添加新的事件系统文件
2. 现有代码继续使用旧接口
3. 新功能使用新接口

### Step 2: 逐步迁移（1-2周）
1. 为核心系统添加事件系统支持
2. LevelSys, MoneySys, BagSys 等改为事件驱动
3. 测试新旧系统共存

### Step 3: 全面切换（1周）
1. 所有系统切换到新接口
2. 移除旧的事件总线代码
3. 性能测试和优化

### Step 4: 清理（1-2天）
1. 移除兼容层代码
2. 更新文档
3. 代码审查

---

## 八、注意事项

### 1. 避免死循环
```go
// ❌ 错误：事件处理器中发布相同事件
mgr.Subscribe(event.EventAddExp, 10, func(ctx context.Context, e *event.Event) error {
    // 这会导致无限循环！
    mgr.PublishLocal(event.NewEvent(event.EventAddExp, ...))
    return nil
})

// ✅ 正确：发布不同的事件
mgr.Subscribe(event.EventAddExp, 10, func(ctx context.Context, e *event.Event) error {
    // 触发升级事件
    mgr.PublishLocal(event.NewEvent(event.EventRoleUpLv, ...))
    return nil
})
```

### 2. Context 超时
```go
// 处理器应该尊重 context 的超时
mgr.Subscribe(event.EventSomeEvent, 10, func(ctx context.Context, e *event.Event) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-time.After(100 * time.Millisecond):
        // 执行逻辑
    }
    return nil
})
```

### 3. 邮箱大小
```go
// 根据事件频率选择合适的邮箱大小
// - 低频事件：64-128
// - 中频事件：256-512
// - 高频事件：1024-2048

mgr := event.NewSystemMgr(playerID, 256) // 一般推荐 256
```

### 4. 优先级规划
```go
// 建议的优先级范围：
// 100+ : 最高优先级（安全检查、认证等）
// 50-99: 高优先级（核心业务逻辑）
// 10-49: 普通优先级（一般业务逻辑）
// 1-9  : 低优先级（统计、日志等）
// 0    : 默认优先级
// <0   : 最低优先级（清理任务等）
```

---

## 九、测试建议

### 单元测试
```go
func TestEventSystem(t *testing.T) {
    // 创建测试 actor
    mgr := event.NewSystemMgr("test_actor", 64)
    defer mgr.Close()
    
    // 订阅事件
    received := false
    mgr.Subscribe(event.EventRoleLogin, 10, func(ctx context.Context, e *event.Event) error {
        received = true
        return nil
    })
    
    // 发布事件
    evt := event.NewEvent(event.EventRoleLogin, "test_actor")
    mgr.PublishLocal(evt)
    
    // 等待处理
    time.Sleep(100 * time.Millisecond)
    
    // 验证
    if !received {
        t.Error("Event not received")
    }
}
```

### 性能测试
```go
func BenchmarkEventPublish(b *testing.B) {
    mgr := event.NewSystemMgr("bench_actor", 1024)
    defer mgr.Close()
    
    mgr.Subscribe(event.EventRoleLogin, 10, func(ctx context.Context, e *event.Event) error {
        return nil
    })
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        evt := event.NewEvent(event.EventRoleLogin, "bench_actor")
        mgr.PublishLocal(evt)
    }
}
```

---

## 十、FAQ

**Q: 旧代码是否需要立即迁移？**
A: 不需要。新系统提供了兼容层，旧代码可以继续工作。建议逐步迁移。

**Q: 全局事件和本地事件有什么区别？**
A: 本地事件只影响单个 actor，全局事件广播到所有 actor。

**Q: 如何调试事件流？**
A: 可以在 Event 中设置 TraceID，并在日志中打印事件链路。

**Q: 邮箱满了怎么办？**
A: 当前策略是丢弃事件。可以根据业务需求改为阻塞或扩容邮箱。

**Q: 性能如何？**
A: 单个 actor 可以处理 10万+ 事件/秒。全局广播取决于 actor 数量。

---

## 附录：完整的事件类型定义

```go
// event_type.go
package event

type Type uint32

const (
	// ========== 角色事件 (1-100) ==========
	EventRoleLogin  Type = iota + 1 // 角色登录
	EventRoleLogout                 // 角色登出
	EventRoleUpLv                   // 角色升级
	EventAddExp                     // 增加经验
	EventAddMoney                   // 增加货币
	EventAddItem                    // 增加道具

	// ========== 战斗事件 (101-200) ==========
	EventEnterBattle Type = 101 + iota // 进入战斗
	EventLeaveBattle                   // 离开战斗
	EventSkillCast                     // 技能释放
	EventDamage                        // 造成伤害
	EventHeal                          // 治疗
	EventDeath                         // 死亡
	EventRevive                        // 复活

	// ========== 世界事件 (201-300) ==========
	EventWorldBossSpawn Type = 201 + iota // 世界 BOSS 刷新
	EventWorldBossDead                    // 世界 BOSS 死亡
	EventServerAnnouncement               // 服务器公告
	EventServerShutdown                   // 服务器关闭
	EventWeatherChange                    // 天气变化

	// ========== 副本事件 (301-400) ==========
	EventDungeonEnter Type = 301 + iota // 进入副本
	EventDungeonLeave                   // 离开副本
	EventDungeonComplete                // 副本完成
	EventDungeonFailed                  // 副本失败

	// ========== 社交事件 (401-500) ==========
	EventTeamCreate Type = 401 + iota // 创建队伍
	EventTeamJoin                     // 加入队伍
	EventTeamLeave                    // 离开队伍
	EventGuildCreate                  // 创建公会
	EventGuildJoin                    // 加入公会
	EventGuildLeave                   // 离开公会
	EventFriendAdd                    // 添加好友
	EventFriendRemove                 // 删除好友

	// ========== 交易事件 (501-600) ==========
	EventTradeStart Type = 501 + iota // 开始交易
	EventTradeComplete                // 交易完成
	EventTradeCancel                  // 取消交易
	EventAuctionBid                   // 拍卖出价
	EventAuctionSold                  // 拍卖成交

	// ========== 任务事件 (601-700) ==========
	EventQuestAccept Type = 601 + iota // 接受任务
	EventQuestComplete                 // 完成任务
	EventQuestFailed                   // 任务失败
	EventQuestUpdate                   // 任务更新

	// ========== 邮件事件 (701-800) ==========
	EventMailReceive Type = 701 + iota // 收到邮件
	EventMailRead                      // 读取邮件
	EventMailDelete                    // 删除邮件

	// ========== 成就事件 (801-900) ==========
	EventAchievementUnlock Type = 801 + iota // 解锁成就
	EventAchievementProgress                 // 成就进度

	// ========== 系统事件 (901-1000) ==========
	EventSystemMaintenance Type = 901 + iota // 系统维护
	EventSystemUpdate                        // 系统更新
	EventSystemError                         // 系统错误
)
```
